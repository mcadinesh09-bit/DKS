<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>ALLEN Result Generator</title>
    <!-- Google Fonts: Inter -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&display=swap" rel="stylesheet">
    <!-- Library CDNs -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf-autotable/3.5.28/jspdf.plugin.autotable.min.js"></script>
    <style>
      /* --- UI Styles based on Allen Dashboard --- */
      :root {
          --primary-color: #003366;      /* Allen Dark Blue */
          --secondary-color: #0059b3;    /* Allen Lighter Blue */
          --accent-color: #2563eb;       /* A vibrant blue for links/highlights */
          --success-color: #16a34a;      /* Green for success */
          --error-color: #dc2626;        /* Red for errors */
          --bonus-color: #2563eb;        /* Blue for Bonus */
          
          --bg-body: #f8f9fa;            /* Light grey page background */
          --bg-card: #ffffff;            /* White for cards/containers */
          --bg-header: #eef2ff;          /* Light blue for table headers */
          --bg-row-alt: #f9fafb;         /* Alternating row color */

          --text-dark: #1f2937;          /* Main text color */
          --text-light: #6b7280;         /* Lighter text for descriptions */
          --text-primary: #003366;       /* Text in primary color */
          --border-color: #e5e7eb;       /* Standard border color */
      }

      /* REPLACE WITH THIS CODE */
/* REPLACE WITH THIS CODE */
body {
    font-family: 'Inter', system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", 
                 Roboto, "Helvetica Neue", Arial, "Noto Sans", sans-serif, 
                 "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", "Noto Color Emoji";
    margin: 0;
    background-color: #FAFBFF; /* Changed to the new color */
    color: var(--text-dark);
    transition: background-color 0.3s ease;
}

      /* Login Page Styles */
      .login-container {
          display: flex;
          justify-content: center;
          align-items: center;
          height: 100vh;
          background-color: var(--bg-body);
      }
      .login-card {
          width: 100%;
          max-width: 400px;
          padding: 3rem 2rem;
          background-color: var(--bg-card);
          border-radius: 8px;
          box-shadow: 0 4px 12px rgba(0,0,0,0.1);
          text-align: center;
      }
      .login-card h2 {
          font-size: 24px;
          font-weight: 800;
          color: var(--primary-color);
          margin-bottom: 2rem;
      }
      .login-input-group {
          margin-bottom: 1.5rem;
          text-align: left;
      }
      .login-input-group label {
          font-size: 14px;
          font-weight: 600;
          display: block;
          margin-bottom: 8px;
      }
      .login-input-group input {
          width: 100%;
          padding: 12px;
          border-radius: 8px;
          border: 1px solid var(--border-color);
          font-size: 14px;
          box-sizing: border-box;
      }
      .login-button {
          width: 100%;
          padding: 12px;
          background-color: var(--primary-color);
          color: white;
          font-size: 16px;
          font-weight: 700;
          border: none;
          border-radius: 8px;
          cursor: pointer;
          transition: background-color 0.3s ease;
      }
      .login-button:hover {
          background-color: var(--secondary-color);
      }
      .login-error-message {
          color: var(--error-color);
          font-size: 14px;
          margin-top: 1rem;
          display: none;
      }
      
      /* Header */
/* REPLACE WITH THIS CODE */
/* REPLACE WITH THIS CODE */
.header {
    width: 100%;
    /* background, box-shadow, and position properties removed */
    padding: 3rem 1rem;
    display: flex;
    align-items: center;
    justify-content: space-between;
    box-sizing: border-box;
}


      .header-main-title {
          display: flex;
          align-items: center;
          gap: 12px;
          font-weight: 800; /* Changed to 800 for extra bold */
          font-size: 20px;
          color: var(--primary-color);
      }
      .header-main-title img {
          height: 30px;
      }

      /* Main Container */
      /* REPLACE WITH THIS CODE */
/* Main Container */
      .container {
          max-width: 1800px;
          margin: 0.5rem auto;
          background: var(--bg-card);
          padding: 2rem;
          border-radius: 12px;
          box-shadow: 0 4px 12px rgba(0,0,0,0.05);
      }

      /* NEW Primary Tabs */
      /* REPLACE WITH THIS CODE */
/* REPLACE WITH THIS CODE */
/* You will find this block */
.primary-tabs-container {
    display: flex;
    gap: 4px;
    margin-bottom: 0.0rem;
}


.tabs-wrapper {
    display: flex;
    align-items: center;
    justify-content: space-between;
    background: #f1f5f9; /* Changed to light gray */
    padding: 0.75rem 1.5rem;
    border-radius: 12px;
    box-shadow: 0 4px 12px rgba(0,0,0,0.05);
    margin-bottom: 1.5rem;
}


      /* REPLACE WITH THIS CODE */
.primary-tab-button {
    padding: 10px 20px;
    font-size: 15px;
    font-weight: 600;
    border: none;
    background: transparent;
    color: var(--text-light);
    cursor: pointer;
    border-radius: 50px; /* Makes the button shape rounded */
    transition: color 0.2s, background-color 0.2s;
}

.primary-tab-button:hover:not(.active) {
    background-color: var(--bg-header); /* Adds a subtle hover effect to inactive tabs */
    color: var(--primary-color);
}

.primary-tab-button.active {
    color: #FFFFFF; /* White text for active tab */
    background-color: var(--primary-color); /* Dark blue background for active tab */
    box-shadow: 0 2px 8px rgba(0, 51, 102, 0.2);
}
      
      /* Form Grid & Inputs */
      .form-grid {
          display: grid;
          grid-template-columns: 2fr 1fr; /* Set column ratio for wider Test Name and narrower Test Date */
          gap: 1.5rem;
          margin-bottom: 2rem;
      }
      @media (max-width: 768px) {
          .form-grid {
              grid-template-columns: 1fr; /* Stack columns on smaller screens */
          }
      }
      label {
          font-size: 14px;
          font-weight: 600;
          display: block;
          margin-bottom: 8px;
          color: var(--text-dark);
      }
      input[type="text"], input[type="date"], select {
          width: 100%;
          padding: 12px;
          border-radius: 8px;
          border: 1px solid var(--border-color);
          font-size: 14px;
          box-sizing: border-box;
          transition: border-color 0.2s, box-shadow 0.2s;
      }
      input[type="text"]:focus, input[type="date"]:focus, select:focus {
          outline: none;
          border-color: var(--accent-color);
          box-shadow: 0 0 0 3px rgba(37, 99, 235, 0.2);
      }
      input[type="date"]::-webkit-datetime-edit-year-field { opacity: 1; }
      input[type="date"]::-webkit-datetime-edit-month-field { opacity: 1; }
      input[type="date"]::-webkit-datetime-edit-day-field { opacity: 1; }

      /* Custom placeholder for date input */
      input[type="date"]::before {
          content: attr(placeholder);
          color: var(--text-light);
          width: 100%;
      }
      input[type="date"].has-value::before, input[type="date"]:focus::before {
           content: '';
      }
      input[type="date"]:valid::before {
           content: '';
      }

      /* File Upload Blocks */
      .file-upload-section h3 {
          font-size: 18px;
          color: var(--text-primary);
          margin-bottom: 1.5rem;
          font-weight: 700;
      }

.upload-block {
    background: #f1f5f9; /* Changed to light gray */
    border: none;
    padding: 1.25rem;
    margin-bottom: 1rem;
    border-radius: 12px;
    display: flex;
    justify-content: space-between;
    align-items: center;
    flex-wrap: wrap;
    gap: 1rem;
    transition: border-color 0.3s, background-color 0.3s;
}

 .upload-block.uploaded-file {
          border-color: var(--success-color);
          background-color: #f0fdf4;
      }
      .upload-block-left {
          flex-grow: 1;
      }
      .upload-block-text {
          font-weight: 600;
          font-size: 16px;
      }
      .upload-block-text .description {
          font-size: 13px;
          color: var(--text-light);
          font-weight: 400;
          display: block;
          margin-top: 4px;
      }
     
/* REPLACE WITH THIS CODE */
.description-highlight {
    color: #f5365c; /* Changed to yellow */
    font-weight: 500;
    font-size: 14px;
}
      .upload-block input[type="file"] { display: none; }
      .file-upload-btn {
          background: var(--primary-color);
          color: white;
          padding: 10px 20px;
          border-radius: 8px;
          cursor: pointer;
          font-size: 14px;
          font-weight: 600;
          transition: background-color 0.2s, transform 0.2s;
          display: inline-flex;
          align-items: center;
          gap: 8px;
      }
      .file-upload-btn:hover {
          background: var(--secondary-color);
          transform: translateY(-1px);
      }
      .file-upload-btn.uploaded {
          background-color: var(--success-color);
      }
      .file-name-display {
          font-size: 14px;
          color: var(--text-light);
          margin-top: 8px;
          font-style: italic;
          word-break: break-all;
      }
      .info-btn {
          background: none; border: none; padding: 0; margin: 0 0 0 8px;
          cursor: pointer; color: var(--accent-color); display: inline-flex;
          align-items: center; justify-content: center;
      }

      /* Main Action Button */
      .button-container {  
          display: flex;
          justify-content: center;
          align-items: center;
          gap: 1rem;
          margin-top: 2.5rem;
          flex-wrap: wrap;
      }
      .btn-generate {
          background: var(--primary-color);
          color: white;
          font-weight: 700;
          font-size: 16px;
          padding: 14px 35px;
          border: none;
          border-radius: 50px;
          cursor: pointer;
          transition: all 0.3s ease;
          box-shadow: 0 4px 15px rgba(0, 51, 102, 0.2);
          display: inline-flex;
          align-items: center;
          gap: 10px;
      }
      .btn-generate:hover {
          background: var(--secondary-color);
          box-shadow: 0 6px 20px rgba(0, 51, 102, 0.3);
          transform: translateY(-2px);
      }
      .btn-generate:disabled {
          background: #9ca3af; cursor: not-allowed;
          box-shadow: none; transform: none;
      }

      /* Results & Tables */
      .results-section { margin-top: 2rem; }
      .table-wrapper {
          width: 100%;
          overflow-x: auto;
      }
      .results-table, .summary-table {
          width: 100%;
          border-collapse: collapse;
          margin-top: 1.5rem;
          border-radius: 8px;
          box-shadow: 0 2px 8px rgba(0,0,0,0.06);
          border: 1px solid var(--border-color);
      }
      /* REPLACE WITH THIS CODE */
.results-table th, .summary-table th {
    background-color: #f8f9fa; /* Light gray background */
    color: var(--text-primary); /* Dark blue text */
    font-weight: 600; /* Slightly adjusted font-weight */
    text-transform: uppercase;
    font-size: 11px; /* Slightly smaller font size */
    padding: 12px 15px;
    text-align: center;
    position: sticky;
    top: 0;
    z-index: 1;
    border: 1px solid #e5e7eb; /* Adds all grid lines */
}
      /* REPLACE WITH THIS CODE */
/* REPLACE WITH THIS CODE */
.results-table td, .summary-table td {
    padding: 12px 15px;
    border-bottom: 1px solid var(--border-color);
    border-right: 1px solid var(--border-color); /* Adds vertical lines */
    font-size: 14px;
    text-align: center;
    background-color: var(--bg-card); 
}
/* Add a rule for the first cell in each row to have a left border */
.results-table td:first-child, .summary-table td:first-child {
    border-left: 1px solid var(--border-color);
}      .results-table tr:last-child td, .summary-table tr:last-child td {
          border-bottom: none;
      }
      .results-table tr:nth-child(even), .summary-table tr:nth-child(even) {
          background-color: var(--bg-row-alt);
      }
      .results-table tr:hover, .summary-table tr:hover {
          background-color: #f3f4f6;
      }
      .results-header {
          display: flex;
          justify-content: space-between;
          align-items: flex-end;
          margin-bottom: 1rem;
          flex-wrap: wrap;
          gap: 1rem;
      }
      .results-header-title h2 {
          margin: 0;
          font-size: 22px;
          color: var(--text-primary);
      }
      .results-header-title p {
          margin: 4px 0 0;
          font-weight: 600;
          color: var(--text-light);
      }

      .sticky-col {
          position: sticky;
          left: 0;
          background-color: var(--bg-card);
          z-index: 2;
      }
      .results-table th.sticky-col, .summary-table th.sticky-col {
          background-color: var(--bg-header);
      }
      /* REPLACE WITH THIS CODE */
.results-table tr:nth-child(even) td.sticky-col, .summary-table tr:nth-child(even) td.sticky-col {
    background-color: var(--bg-card); /* Changed to white */
}

      /* Pagination */
      .pagination-controls {
          display: flex;
          justify-content: space-between;
          align-items: center;
          margin-top: 1.5rem;
          flex-wrap: wrap;
          gap: 1rem;
          font-size: 14px;
      }
      .pagination-info {
          color: var(--text-light);
      }
      .pagination-nav {
          display: flex;
          align-items: center;
          gap: 0.5rem;
      }
      .pagination-nav label {
          margin-bottom: 0;
      }
      .pagination-btn {
          padding: 6px 10px;
          border: 1px solid var(--border-color);
          background-color: var(--bg-card);
          color: var(--text-dark);
          border-radius: 6px;
          cursor: pointer;
          transition: background-color 0.2s;
          display: flex;
          align-items: center;
          justify-content: center;
      }
      .pagination-btn:hover {
          background-color: #f1f5f9;
      }
      .pagination-btn.active {
          background-color: var(--primary-color);
          color: white;
          border-color: var(--primary-color);
      }
      .pagination-btn:disabled {
          cursor: not-allowed;
          opacity: 0.5;
      }

      /* Detailed Results Tabs */
      .results-tabs-container {
          display: flex;
          gap: 0.5rem;
          border-bottom: 1px solid var(--border-color);
          margin-bottom: 1.5rem; /* Added margin to separate from content */
      }
      .results-tab-btn {
          padding: 10px 20px;
          border: none;
          background: none;
          font-size: 16px;
          font-weight: 600;
          color: var(--text-light);
          cursor: pointer;
          border-bottom: 3px solid transparent;
          transition: color 0.2s, border-color 0.2s;
      }
      .results-tab-btn.active {
          color: var(--primary-color);
          border-bottom-color: var(--primary-color);
      }
      .results-tab-content {
          display: none;
          padding-top: 1.5rem;
      }
      .results-tab-content.active {
          display: block;
      }
      .results-tab-header {
          display: flex;
          justify-content: space-between;
          align-items: center;
          margin-bottom: 1rem;
      }
      .results-tab-header h3 {
          margin: 0;
          font-size: 18px;
          color: var(--text-primary);
      }

      /* Cell Styling */
      .correct-answer-cell { background-color: #dcfce7; color: #15803d; font-weight: 600; }
      .wrong-answer-cell { background-color: #fee2e2; color: #b91c1c; font-weight: 600; }
      .partially-correct-cell { background-color: #fef3c7; color: #b45309; font-weight: 600; }
      .bonus-answer-cell { background-color: #e0f2fe; color: #0c4a6e; font-weight: 600; text-align: center; }
      
      /* Download Buttons */
      .download-buttons-container {
          display: flex; justify-content: flex-end; gap: 1rem;
          flex-wrap: wrap;
          margin-bottom: 10px; /* Added margin to keep buttons from touching other elements */
      }
      /* REPLACE WITH THIS CODE */
/* REPLACE WITH THIS CODE */
.btn-download {
    background-color: #233A6C; /* Default color: Dark Blue */
    color: #FFFFFF; /* Default text color: White */
    font-weight: 600; padding: 10px 20px; border: none;
    border-radius: 8px; cursor: pointer;
    transition: background-color 0.2s, transform 0.2s, color 0.2s;
    position: relative;
}
.btn-download:hover {
    background-color: #fbbc04; /* Hover color: Yellow */
    color: #000000; /* Hover text color: Black for readability */
    transform: translateY(-2px);
}
      .dropdown-menu {
          position: absolute; top: 100%; left: 0; background-color: white;
          border: 1px solid var(--border-color); border-radius: 8px;
          box-shadow: 0 4px 8px rgba(0,0,0,0.1); min-width: 160px;
          z-index: 100; display: none; flex-direction: column; overflow: hidden;
      }
      .dropdown-menu.show { display: flex; }
      .dropdown-item {
          padding: 10px 15px; text-align: left; color: #374151;
          text-decoration: none; cursor: pointer; transition: background-color 0.2s;
      }
      .dropdown-item:hover { background-color: #f3f4f6; }

      /* Modal */
      .modal-overlay {
          position: fixed; top: 0; left: 0; width: 100%; height: 100%;
          background-color: rgba(0, 0, 0, 0.6); display: flex;
          justify-content: center; align-items: center; z-index: 1000;
          opacity: 0; visibility: hidden; transition: opacity 0.3s ease;
      }
      .modal-overlay.show { opacity: 1; visibility: visible; }
      .modal-content {
          background-color: white;
          padding: 20px;
          border-radius: 8px;
          box-shadow: 0 5px 15px rgba(0,0,0,0.3);
          width: 90%;
          max-width: 400px; /* Reduced size */
          text-align: center;
          position: relative;
          transform: scale(0.9);
          transition: transform 0.3s ease;
      }
      .modal-overlay.show .modal-content { transform: scale(1); }
      .modal-close-btn {
          position: absolute; top: 10px; right: 15px; font-size: 28px;
          font-weight: bold; color: #aaa; cursor: pointer; transition: color 0.2s;
      }
      #modalTitle { margin-top: 0; font-size: 24px; color: var(--primary-color); margin-bottom: 15px; }
      #modalTitle.error { color: var(--error-color); }
      .ranking-list { list-style: none; padding: 0; margin-top: 20px; }
      .ranking-item { background-color: #f1f5f9; padding: 12px; margin-bottom: 8px; border-radius: 6px; border: 1px solid var(--border-color); display: flex; align-items: center; justify-content: space-between; font-weight: 500; }
      .ranking-item input[type="number"] { width: 60px; padding: 6px; text-align: center; border-radius: 4px; border: 1px solid #ccc; font-size: 14px; }


      /* Data Merger Tab */
      .merger-tab-nav {
          display: flex;
          gap: 1rem;
          border-bottom: 1px solid var(--border-color);
          margin-bottom: 1.5rem;
      }
      .merger-tab-nav .tab-btn {
          padding: 10px 15px;
          border: none;
          border-bottom: 3px solid transparent;
          background: none;
          font-weight: 600;
          color: var(--text-light);
          cursor: pointer;
      }
      .merger-tab-nav .tab-btn.active {
          color: var(--primary-color);
          border-bottom-color: var(--primary-color);
      }
      
      /* Utility */
      .spinner {
          border: 4px solid rgba(255, 255, 255, 0.3); border-left-color: #ffffff;
          border-radius: 50%; width: 20px; height: 20px;
          animation: spin 1s linear infinite; display: none;
      }
      .spinner.show { display: inline-block; }
      @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
      .scrollable-table-container { overflow: auto; width: 100%; max-height: 70vh; }
      
      /* --- PDF Styles --- */
      .pdf-content { font-family: 'Inter', sans-serif; padding: 20px; color: #000; font-size: 12px; line-height: 1.5; box-sizing: border-box; width: 210mm; min-height: 297mm; margin: 0 auto; background-color: #fff; font-weight: 500; }
      /* MODIFICATION: Reverted main PDF header to plain text (removed black box) */
      .pdf-header { text-align: center; margin-bottom: 20px; }
      .pdf-header h1 { font-size: 20px; font-weight: 800; margin-bottom: 5px; color: #000; }
      .pdf-header p { font-size: 10px; color: #000; }
      .pdf-header .test-info-line { font-size: 14px; font-weight: 600; margin-top: 10px; color: #000; }
      .student-info { margin-bottom: 15px; border: 1px solid #000; padding: 10px; border-radius: 8px; }
      .student-info p { margin: 0 0 5px 0; color: #000; font-weight: 600; }
      .student-info strong { color: #000; font-weight: 700; }
      .subjects-container { display: flex; justify-content: space-between; gap: 10px; align-items: flex-start; }
      .pdf-subject-column { flex: 1; border: 1px solid #000; padding: 8px; border-radius: 8px; }
      .pdf-subject-column h3 { font-size: 14px; font-weight: 700; margin: 0 0 10px 0; color: #000; text-align: center; }
      .pdf-response-table { width: 100%; border-collapse: collapse; }
      .pdf-response-table td { padding: 4px; font-size: 10px; border: 0.5px solid #000; text-align: center; font-weight: 600; }
      /* MODIFICATION: Made subject table headers black with white text */
      .pdf-response-table th { background-color: #333333; color: #FFFFFF; font-weight: 700; padding: 4px; font-size: 10px; border: 0.5px solid #000; text-align: center; }
      .grid-table { width: 100%; margin: 0 auto; border-collapse: collapse; table-layout: fixed; }
      .grid-table th, .grid-table td { border: 1px solid #000; width: 16px; height: 16px; text-align: center; vertical-align: middle; font-size: 9px; font-weight: bold; color: #000; padding: 0; }
      .grid-table th { background-color: #e0e0e0; }
      .grid-table td.correct { background-color: #dcfce7; color: #15803d; }
      .grid-table td.wrong { background-color: #fee2e2; color: #b91c1c; }

      /* Merged Test specific styles */
      .merger-tab-content .button-container {
          display: flex;
          justify-content: center;
          align-items: center;
          flex-wrap: wrap;
          gap: 1rem;
          margin-top: 2.5rem;
      }

      /* Button size consistency */
      .btn-generate, .btn-download {
          min-width: 150px;
          text-align: center;
      }

      /* Form input width consistency */
      .form-grid input, .form-grid select {
          width: 100%;
      }
      
      .correct-count-cell { color: var(--success-color); font-weight: 600; }
      .incorrect-count-cell { color: var(--error-color); font-weight: 600; }
      .left-count-cell { color: var(--text-dark); }
      
      .btn-clear {
          background: #eef2f5;
          color: #6b7280;
          border: 1px solid var(--border-color);
          font-weight: 600;
          font-size: 14px;
          padding: 10px 20px;
          border-radius: 8px;
          cursor: pointer;
          transition: background-color 0.2s, transform 0.2s;
      }
      .btn-clear:hover {
          background-color: #e2e8f0;
          transform: translateY(-1px);
      }

      /* --- NEW: Statistics Box --- */
      .stats-container {
          display: grid;
          grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
          gap: 1rem;
          margin-bottom: 1rem;
          padding: 1.5rem;
          background-color: #FFFFFF;
          border: 1px solid var(--border-color);
          border-radius: 12px;
      }
      .stat-box {
          text-align: center;
      }
      .stat-box .value {
          font-size: 24px;
          font-weight: 700;
          color: var(--primary-color);
      }
      .stat-box .label {
          font-size: 14px;
          font-weight: 500;
          color: var(--text-light);
          margin-top: 4px;
      }
      .stat-box .value.high { color: var(--success-color); }
      .stat-box .value.low { color: var(--error-color); }
</style>


</head>
<body>
    
    <!-- Main Application Content (Initially Hidden) -->
    <div id="mainApp">
        <!-- New Header -->
        <div class="header">
            <div class="header-main-title">
                <span>Test Manager | RACE</span>
            </div>
        </div>

        <!-- Error/Message Modal -->
        <div id="errorModal" class="modal-overlay">
            <div class="modal-content">
                <span class="modal-close-btn">&times;</span>
                <h2 id="modalTitle">Error</h2>
                <p id="modalMessage"></p>
            </div>
        </div>

        <!-- Ranking Criteria Modal -->
        <div id="rankingModal" class="modal-overlay">
            <div class="modal-content">
                <span class="modal-close-btn" id="closeRankingModal">&times;</span>
                <h2 id="rankingModalTitle">Set Ranking Criteria</h2>
                <p>Enter a priority number for each subject (1 = highest priority).</p>
                <ul id="subjectRankList" class="ranking-list"></ul>
                <button id="saveRankCriteriaBtn" class="btn-generate" style="margin-top: 20px;">Save and Generate</button>
            </div>
        </div>
        
        <!-- Main Content Area -->
        <div class="container">
            <div class="tabs-wrapper">
    <div class="primary-tabs-container">
        <button id="objectiveTabBtn" class="primary-tab-button active">Objective Test</button>
        <button id="subjectiveTabBtn" class="primary-tab-button">Subjective Test</button>
        <button id="mergerTabBtn" class="primary-tab-button">Merged Multiple</button>
    </div>
</div>

            <!-- Tab 1: Objective & Subjective Result Generator -->
            <div id="objectiveSubjectiveApp" class="tab-content-section" style="display: block;">
                <div class="form-grid" style="background: var(--bg-card); padding: 1.5rem; border-radius: 12px; box-shadow: 0 4px 12px rgba(0,0,0,0.05); border: 0.25px solid ;border-color:#78909c;">
                    <div>
                        <label for="testName">Test Name *</label>
                        <input type="text" id="testName" placeholder="Enter Test Name" style="width: 100%;" />
                    </div>
                    <div>
                        <label for="testDate">Test Date *</label>
                        <input type="date" id="testDate" placeholder="Select Date" onkeydown="return false;" style="width: 100%;" />
                    </div>
                </div>
                
                <!-- Objective Test Section -->
                <div id="objectiveUploadSection" class="file-upload-section" style="display: block;">
                    <h3>Upload Files (Objective) </h3>
                    <h6>Supported Question Type : SC,CS,MP,ML,CM,MC,ID,IM,IS,MM</h6>

                    <div class="upload-block">
                        <div class="upload-block-left">
                            <div class="upload-block-text">
                                Upload Marking Scheme
                                <button id="downloadTemplateBtn" class="info-btn" title="Download Template">
                                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="#233A6C" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-download"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path><polyline points="7 10 12 15 17 10"></polyline><line x1="12" y1="15" x2="12" y2="3"></line></svg>
                                </button>
                            </div>
                            <span class="description description-highlight">Columns: Section | Que.No.| Subject | Ques Type | Correct Answer | Right Marks | Negative Marks | Bonus</span>
                            <div id="file2Name" class="file-name-display">No file chosen</div>
                        </div>
                        <div>
                            <label for="file2" class="file-upload-btn">
                                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path><polyline points="17 8 12 3 7 8"></polyline><line x1="12" y1="3" x2="12" y2="15"></line></svg>
                                <span>Upload</span>
                            </label>
                            <input type="file" id="file2" accept=".xls,.xlsx,.csv" />
                        </div>
                    </div>
                    <div class="upload-block">
                        <div class="upload-block-left">
                            <div class="upload-block-text">
                                Upload Student Responses
                                <button id="downloadResponseTemplateBtn" class="info-btn" title="Download Template" style="display: none;">
                                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path><polyline points="7 10 12 15 17 10"></polyline><line x1="12" y1="15" x2="12" y2="3"></line></svg>
                                </button>
                            </div>
                            <span class="description" id="responseFileFormats">Supports: DAT, XLSX, CSV formats</span>
                            <div id="formatSelectorDiv" style="display: flex; align-items: center; gap: 8px; margin-top: 10px;">
                                <label for="formatSelector" style="margin-bottom: 0; font-weight: 500;">Response Source:</label>
                                <select id="formatSelector" style="width: auto; padding: 8px; border-radius: 6px;">
                                    <option value="jee_dat_cbt">JEE DAT</option>
                                    <option value="jee_excel">JEE EXCEL (126)</option>
                                    <option value="neet_other">JEE CBT</option>
                                    <option value="neet_other">NEET & OTHER</option>
                                </select>
                            </div>
                            <div id="file1Name" class="file-name-display">No file chosen</div>
                        </div>
                        <div>
                            <label for="file1" class="file-upload-btn">
                                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path><polyline points="17 8 12 3 7 8"></polyline><line x1="12" y1="3" x2="12" y2="15"></line></svg>
                                <span>Upload</span>
                            </label>
                            <input type="file" id="file1" accept=".dat,.xls,.xlsx,.csv" />
                        </div>
                    </div>
                    <div class="upload-block">
                        <div class="upload-block-left">
                            <div class="upload-block-text">
                                Upload Student Details (Optional)
                                <button id="downloadDetailsTemplateBtn" class="info-btn" title="Download Template">
                                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path><polyline points="7 10 12 15 17 10"></polyline><line x1="12" y1="15" x2="12" y2="3"></line></svg>
                                </button>
                            </div>
                            <span class="description description-highlight">Columns: FRMID | Student Name | Batch</span>
                            <div id="file3Name" class="file-name-display">No file chosen</div>
                        </div>
                        <div>
                            <label for="file3" class="file-upload-btn">
                                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path><polyline points="17 8 12 3 7 8"></polyline><line x1="12" y1="3" x2="12" y2="15"></line></svg>
                                <span>Upload</span>
                            </label>
                            <input type="file" id="file3" accept=".xls,.xlsx,.csv" />
                        </div>
                    </div>
                </div>

                <!-- Subjective Test Section -->
                <div id="subjectiveUploadSection" class="file-upload-section" style="display: none;">
                    <h3>Upload Files (Subjective)</h3>
                    <div class="upload-block">
                        <div class="upload-block-left">
                            <div class="upload-block-text">
                                Upload Subjective Marks
                                
                            </div>
                            <span class="description description-highlight">Columns: FRMID | Subject Marks | Max marks | Subject Max Marks (e.g., maths | maths max marks)</span>
                            <div id="subjectiveFileName" class="file-name-display">No file chosen</div>
                        </div>
                        <div>
                            <label for="subjectiveFile" class="file-upload-btn">
                                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path><polyline points="17 8 12 3 7 8"></polyline><line x1="12" y1="3" x2="12" y2="15"></line></svg>
                                <span>Upload</span>
                            </label>
                            <input type="file" id="subjectiveFile" accept=".xls,.xlsx,.csv" />
                        </div>
                    </div>
                    <div class="upload-block">
                        <div class="upload-block-left">
                            <div class="upload-block-text">
                                Upload Student Details (Optional)
                                <button id="downloadDetailsTemplateBtnSubjective" class="info-btn" title="Download Template">
                                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path><polyline points="7 10 12 15 17 10"></polyline><line x1="12" y1="15" x2="12" y2="3"></line></svg>
                                </button>
                            </div>
                            <span class="description description-highlight">Columns: FRMID | Student Name | Batch</span>
                            <div id="subjectiveDetailsFileName" class="file-name-display">No file chosen</div>
                        </div>
                        <div>
                            <label for="subjectiveDetailsFile" class="file-upload-btn">
                                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path><polyline points="17 8 12 3 7 8"></polyline><line x1="12" y1="3" x2="12" y2="15"></line></svg>
                                <span>Upload</span>
                            </label>
                            <input type="file" id="subjectiveDetailsFile" accept=".xls,.xlsx,.csv" />
                        </div>
                    </div>
                </div>

                <div class="button-container">
                    <button id="processBtn" class="btn-generate" disabled>
                        <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polygon points="13 2 3 14 12 14 11 22 21 10 12 10 13 2"></polygon></svg>
                        <span>Generate Result</span>
                        <div id="spinner" class="spinner"></div>
                    </button>
                    <button id="clearObjectiveSubjectiveBtn" class="btn-clear" style="margin-left: auto;">Clear All</button>
                </div>
                <!-- *** MODIFIED RESULTS CONTAINER *** -->
                <div id="resultsContainer" class="results-section" style="display: none;">
                    <div id="resultsTabsContainer" class="results-tabs-container">
                        <button class="results-tab-btn active" data-tab="summaryResults">Summary Result</button>
                        <button class="results-tab-btn" data-tab="detailedResults">Detailed Result</button>
                        <button class="results-tab-btn" data-tab="responseAnalysis">Response Analysis</button>
                    </div>
                    <div id="summaryResults" class="results-tab-content active" style="padding-top: 0;"></div>
                    <div id="detailedResults" class="results-tab-content"></div>
                    <div id="responseAnalysis" class="results-tab-content"></div>
                </div>
            </div>
            
            <!-- Tab 2: Data Merger -->
            <div id="dataMergerApp" class="tab-content-section" style="display: none;">
                <div id="mergerAppContent">
                    <div class="merger-tab-nav">
                        <button id="objSubjMergerTabBtn" class="tab-btn active">Objective + Subjective</button>
                        <button id="objObjMergerTabBtn" class="tab-btn">Objective + Objective</button>
                    </div>
                    <!-- Tab 1: Objective + Subjective Merger -->
                    <div id="objSubjMerger" class="merger-tab-content active">
                       <div class="form-grid" style="background: var(--bg-card); padding: 1.5rem; border-radius: 8px; border: 1px solid ;border-color:#78909c;">
                            <div>
                                <label for="testNameInput1">Test Name (Optional)</label>
                                <input type="text" id="testNameInput1" placeholder="e.g., Test-1 JEE(M+A)" style="width: 100%;">
                            </div>
                            <div>
                                <label for="testDateInput1">Test Date (Optional)</label>
                                <input type="date" id="testDateInput1" onkeydown="return false;" placeholder="Select Date" style="width: 100%;">
                            </div>
                        </div>
                        <div class="form-grid" style="display: block;">
                            <div class="upload-block">
                                <div class="upload-block-left">
                                    <div class="upload-block-text">Objective Test Data</div>
                                    <p id="file1Name-merger" class="file-name">No file chosen</p>
                                </div>
                                <div>
                                    <label for="file1-merger" class="file-upload-btn">Upload File</label>
                                    <input type="file" id="file1-merger" accept=".xlsx, .xls">
                                </div>
                            </div>
                            <div class="upload-block">
                                <div class="upload-block-left">
                                    <div class="upload-block-text">Subjective Test Data</div>
                                    <p id="file2Name-merger" class="file-name">No file chosen</p>
                                </div>
                                <div>
                                    <label for="file2-merger" class="file-upload-btn">Upload File</label>
                                    <input type="file" id="file2-merger" accept=".xlsx, .xls">
                                </div>
                            </div>
                        </div>
                        <div class="button-container">
                            <button id="mergeBtn" class="btn-generate" disabled>Process & Merge Files</button>
                            <button id="clearObjSubjMergerBtn" class="btn-clear" style="margin-left: auto;">Clear All</button>
                            <p id="mergerErrorMessage" class="message-box error" style="display: none;"></p>
                        </div>
                        <div id="mergerResultsSection" class="results-section" style="display: none;">
                            <div class="results-header">
                                <div class="results-header-title">
                                    <h3 style="margin: 0; font-weight: 700;">Merged Results</h3>
                                </div>
                                <div class="download-buttons-container">
                                    <button id="mergerDownloadExcelBtn" class="btn-download">Download as Excel</button>
                                    <button id="mergerDownloadPdfBtn" class="btn-download" style="background-color: #c81e1e;">Download as PDF</button>
                                </div>
                            </div>
                            <div class="table-wrapper">
                                <table id="mergerTableContainer" class="summary-table"></table>
                            </div>
                            <div id="mergerPagination1"></div>
                        </div>
                    </div>
                    <!-- Tab 2: Objective + Objective Merger -->
                    <div id="objObjMerger" class="merger-tab-content" style="display: none;">
                        <div class="form-grid" style="background: var(--bg-card); padding: 1.5rem; border-radius: 8px; border: 1px solid var(--border-color);">
                            <div>
                                <label for="testNameInput2">Test Name (Optional)</label>
                                <input type="text" id="testNameInput2" placeholder="e.g., Test-1 JEE(M+A)" style="width: 100%;">
                            </div>
                            <div>
                                <label for="testDateInput2">Test Date (Optional)</label>
                                <input type="date" id="testDateInput2" onkeydown="return false;" placeholder="Select Date" style="width: 100%;">
                            </div>
                        </div>
                        <div class="form-grid" style="display: block;">
                            <div class="upload-block">
                                <div class="upload-block-left">
                                    <div class="upload-block-text">Paper 1 Data</div>
                                    <p id="file3Name-merger" class="file-name">No file chosen</p>
                                </div>
                                <div>
                                    <label for="file3-merger" class="file-upload-btn">Upload File</label>
                                    <input type="file" id="file3-merger" accept=".xlsx, .xls">
                                </div>
                            </div>
                            <div class="upload-block">
                                <div class="upload-block-left">
                                    <div class="upload-block-text">Paper 2 Data</div>
                                    <p id="file4Name-merger" class="file-name">No file chosen</p>
                                </div>
                                <div>
                                    <label for="file4-merger" class="file-upload-btn">Upload File</label>
                                    <input type="file" id="file4-merger" accept=".xlsx, .xls">
                                </div>
                            </div>
                        </div>
                        <div class="button-container">
                            <button id="mergeObjObjBtn" class="btn-generate" disabled>Process & Merge Files</button>
                            <button id="clearObjObjMergerBtn" class="btn-clear" style="margin-left: auto;">Clear All</button>
                            <p id="mergerObjObjErrorMessage" class="message-box error" style="display: none;"></p>
                        </div>
                        <div id="mergerObjObjResultsSection" class="results-section" style="display: none;">
                            <div class="results-header">
                                <div class="results-header-title">
                                    <h3 style="margin: 0; font-weight: 700;">Merged Results</h3>
                                </div>
                                <div class="download-buttons-container">
                                    <button id="mergerObjObjDownloadExcelBtn" class="btn-download">Download as Excel</button>
                                    <button id="mergerObjObjDownloadPdfBtn" class="btn-download" style="background-color: #c81e1e;">Download as PDF</button>
                                </div>
                            </div>
                            <div class="table-wrapper">
                               <table id="mergerObjObjTableContainer" class="summary-table"></table>
                            </div>
                            <div id="mergerPagination2"></div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Footer -->
        <div class="footer" style="text-align: center; padding: 20px; font-size: 14px; color: var(--text-light);">
            
            
        </div>
    </div>

<script>
    document.addEventListener('DOMContentLoaded', () => {
        const { jsPDF } = window.jspdf;

        // --- New Clock Logic ---
        function updateClock() {
            const now = new Date();
            const timeString = now.toLocaleTimeString('en-IN', { hour: '2-digit', minute: '2-digit', second: '2-digit' });
        }
        setInterval(updateClock, 1000);
        updateClock(); // Initial call to display time immediately
        // --- End of New Clock Logic ---

        // DOM elements
        const testNameInput = document.getElementById('testName');
        const testDateInput = document.getElementById('testDate');
        const processBtn = document.getElementById('processBtn');
        const spinner = document.getElementById('spinner');
        const clearObjectiveSubjectiveBtn = document.getElementById('clearObjectiveSubjectiveBtn');

        // Main content containers
        const objectiveSubjectiveApp = document.getElementById('objectiveSubjectiveApp');
        const dataMergerApp = document.getElementById('dataMergerApp');

        // Primary Tabs
        const objectiveTabBtn = document.getElementById('objectiveTabBtn');
        const subjectiveTabBtn = document.getElementById('subjectiveTabBtn');
        const mergerTabBtn = document.getElementById('mergerTabBtn');
        const primaryTabs = [objectiveTabBtn, subjectiveTabBtn, mergerTabBtn];

        // Objective elements
        const objectiveUploadSection = document.getElementById('objectiveUploadSection');
        const file1Input = document.getElementById('file1');
        const file2Input = document.getElementById('file2');
        const file3Input = document.getElementById('file3');
        const file1NameSpan = document.getElementById('file1Name');
        const file2NameSpan = document.getElementById('file2Name');
        const file3NameSpan = document.getElementById('file3Name');
        const responseFileFormatsSpan = document.getElementById('responseFileFormats');
        const formatSelectorDiv = document.getElementById('formatSelectorDiv');
        const formatSelector = document.getElementById('formatSelector');
        const downloadTemplateBtn = document.getElementById('downloadTemplateBtn');
        const downloadResponseTemplateBtn = document.getElementById('downloadResponseTemplateBtn');
        const downloadDetailsTemplateBtn = document.getElementById('downloadDetailsTemplateBtn');

        // Subjective elements
        const subjectiveUploadSection = document.getElementById('subjectiveUploadSection');
        const subjectiveFile = document.getElementById('subjectiveFile');
        const subjectiveDetailsFile = document.getElementById('subjectiveDetailsFile');
        const subjectiveFileNameSpan = document.getElementById('subjectiveFileName');
        const subjectiveDetailsFileNameSpan = document.getElementById('subjectiveDetailsFileName');
        const downloadDetailsTemplateBtnSubjective = document.getElementById('downloadDetailsTemplateBtnSubjective');

        // Result elements
        const resultsContainer = document.getElementById('resultsContainer');
        const summaryResultsDiv = document.getElementById('summaryResults');
        const detailedResultsDiv = document.getElementById('detailedResults');
        const responseAnalysisDiv = document.getElementById('responseAnalysis');
        const resultsTabsContainer = document.getElementById('resultsTabsContainer');
        
        // Modal elements
        const errorModal = document.getElementById('errorModal');
        const modalTitle = document.getElementById('modalTitle');
        const modalMessage = document.getElementById('modalMessage');
        const modalCloseBtn = document.querySelector('.modal-close-btn');
        const rankingModal = document.getElementById('rankingModal');
        const closeRankingModalBtn = document.getElementById('closeRankingModal');
        const subjectRankList = document.getElementById('subjectRankList');
        const saveRankCriteriaBtn = document.getElementById('saveRankCriteriaBtn');


        // Global state variables
        let studentData = [];
        let markingScheme = {};
        let studentDetailsMap = new Map();
        let calculatedResults = [];
        let summaryResults = []; // Will now store raw numbers
        let maxMarksBySubject = {};
        let overallMaxMarks = 0;
        let uniqueSubjects = [];
        let uniqueQuestionTypes = [];
        let questionColumns = [];
        let validationMessages = [];
        let currentExamType = 'objective'; // 'objective' or 'subjective'
        let rankingCriteria = []; // For tie-breaking
        let overallStats = {}; // NEW: To store overall statistics

        // Constants
        const PREDEFINED_SUBJECT_ORDER = ['PHYSICS', 'CHEMISTRY', 'MATHS', 'BIOLOGY', 'MAT', 'ENGLISH', 'HINDI']; // Order for displaying subjects
        const SUBJECT_SHORT_NAMES = { 'PHYSICS': 'PHY', 'CHEMISTRY': 'CHEM', 'MATHS': 'MATH', 'BIOLOGY': 'BIO' };
        const PRESERVE_SPACE_FIELDS = ["f041", "f042", "f083", "f084", "f125", "f126"]; // Fields where spaces should be preserved for JEE DAT


        /** UI Helper Functions **/
        function showModal(title, message, type = 'error', timeout = 0) {
            modalTitle.textContent = title;
            modalMessage.innerHTML = message;
            modalTitle.classList.remove('error'); // Reset class
            if (type === 'error') {
                modalTitle.classList.add('error');
            }
            errorModal.classList.add('show');

            // Automatically hide the modal after a timeout if a timeout value is provided
            if (timeout > 0) {
                setTimeout(() => {
                    hideModal();
                }, timeout);
            }
        }

        function hideModal() {
            errorModal.classList.remove('show');
            rankingModal.classList.remove('show');
        }

        function showMessage(message, type = 'info', timeout = 0) {
            const title = type.charAt(0).toUpperCase() + type.slice(1);
            showModal(title, message, type, timeout);
        }

        function hideMessage() {
            hideModal();
        }

        function toggleSpinner(show) {
            spinner.classList.toggle('show', show);
            processBtn.disabled = show;
        }

        /** File Reading Functions (Objective & Subjective) **/
        function readExcelFile(file, isObjectiveResponseFile = false) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        const data = new Uint8Array(e.target.result);
                        const workbook = XLSX.read(data, { type: 'array', raw: true, sheetStubs: true });
                        const firstSheetName = workbook.SheetNames[0];
                        const worksheet = workbook.Sheets[firstSheetName];
                        const jsonData = XLSX.utils.sheet_to_json(worksheet, { header: 1, defval: "" });

                        if (jsonData.length < 1) { reject(new Error('File is empty.')); return; }

                        const headers = jsonData[0].map(h => String(h || '').trim().toLowerCase());
                        const rows = jsonData.slice(1);

                        const parsedData = rows.map(row => {
                            const obj = {};
                            headers.forEach((header, index) => {
                                if (isObjectiveResponseFile && currentExamType === 'jee' && !(header === 'frmid' || header.startsWith('f'))) {
                                    return;
                                }
                                let value = String(row[index] !== undefined ? row[index] : '');
                                if (header === 'frmid' && value.trim() !== '') {
                                    const numValue = parseInt(value, 10);
                                    if (!isNaN(numValue)) {
                                        value = String(numValue);
                                    }
                                }
                                obj[header] = value;
                            });
                            return obj;
                        }).filter(obj => Object.values(obj).some(v => v !== undefined && v !== null && String(v).trim() !== ''));
                        
                        resolve(parsedData);
                    } catch (error) { reject(new Error(`Failed to read Excel/CSV file: ${error.message}. Please ensure it's a valid Excel or CSV format.`)); }
                };
                reader.onerror = () => reject(new Error('Error reading file.'));
                reader.readAsArrayBuffer(file);
            });
        }

        function cleanField(rawChunk, fieldName) {
            const isBlank = /^[\s.]*$/.test(rawChunk);
            if (isBlank) return "x"; // 'x' indicates unattempted

            if (PRESERVE_SPACE_FIELDS.includes(fieldName)) {
                return rawChunk; // Preserve spaces for specific fields like MM
            }

            const onlyAlphaAndSpace = /^[A-Za-z\s]+$/.test(rawChunk);
            if (onlyAlphaAndSpace) {
                return rawChunk.replace(/\s+/g, '').trim(); // Remove all spaces if only alpha and space
            }

            return rawChunk.trim(); // Default trim
        }

        function readJeeDatFile(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        const lines = e.target.result.split(/[\r\n]+/).filter(Boolean);
                        const data = [];
                        const blocks = [
                            { start: 57, end: 137, size: 4, offset: 1 },
                            { start: 137, end: 217, size: 8, offset: 21 },
                            { start: 217, end: 227, size: 1, offset: 31 },
                            { start: 227, end: 267, size: 20, offset: 41 },
                            { start: 267, end: 347, size: 4, offset: 43 },
                            { start: 347, end: 427, size: 8, offset: 63 },
                            { start: 427, end: 437, size: 1, offset: 73 },
                            { start: 437, end: 477, size: 20, offset: 83 },
                            { start: 477, end: 557, size: 4, offset: 85 },
                            { start: 557, end: 637, size: 8, offset: 105 },
                            { start: 637, end: 647, size: 1, offset: 115 },
                            { start: 647, end: 687, size: 20, offset: 125 }
                        ];

                        for (const line of lines) {
                            if (line.length < 687) continue;

                            let fnoField = line.slice(40, 50).trim();
                            if (fnoField !== '') {
                                const numValue = parseInt(fnoField, 10);
                                if (!isNaN(numValue)) {
                                    fnoField = String(numValue);
                                }
                            }
                            const record = { frmid: fnoField };

                            blocks.forEach(block => {
                                const seg = line.slice(block.start, block.end);
                                const count = Math.floor((block.end - block.start) / block.size);

                                for (let i = 0; i < count; i++) {
                                    const col = `f${String(block.offset + i).padStart(3, '0')}`;
                                    const rawValue = seg.slice(i * block.size, (i + 1) * block.size);
                                    record[col] = cleanField(rawValue, col);
                                }
                            });
                            data.push(record);
                        }
                        resolve(data);
                    } catch (error) { reject(new Error(`Failed to process JEE DAT file: ${error.message}. Please ensure it's a valid DAT file.`)); }
                };
                reader.onerror = () => reject(new Error('Error reading file.'));
                reader.readAsText(file, 'UTF-8');
            });
        }

        function readNeetDatFile(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        const lines = e.target.result.split(/[\r\n]+/).filter(Boolean);
                        const data = [];

                        lines.forEach(line => {
                            if (line.trim().length < 231) return;

                            let frmid = line.substring(40, 50).trim();
                            if (frmid !== '') {
                                const numValue = parseInt(frmid, 10);
                                if (!isNaN(numValue)) {
                                    frmid = String(numValue);
                                }
                            }

                            const record = { frmid: frmid };

                            for (let i = 0; i < 200; i++) {
                                const qNoKey = 'f' + String(i + 1).padStart(3, '0');
                                const response = line.charAt(51 + i);
                                record[qNoKey] = response ? response.trim() : '';
                            }
                            data.push(record);
                        });

                        if (data.length === 0) {
                            reject(new Error('No valid data found in the NEET DAT file. Please check the file format and content.'));
                            return;
                        }
                        resolve(data);
                    } catch (error) {
                        reject(new Error(`Failed to process NEET DAT file: ${error.message}.`));
                    }
                };
                reader.onerror = () => reject(new Error('Error reading file.'));
                reader.readAsText(file, 'UTF-8');
            });
        }

        /** Calculation Logic (Objective) **/
        function compareMMAnswersDat(correct, student) {
            const paddedCorrect = (correct || '').padEnd(20, ' ');
            const paddedStudent = (student || '').padEnd(20, ' ');

            const correctBlocks = Array.from({ length: 4 }, (_, i) => paddedCorrect.substring(i * 5, i * 5 + 5));
            const studentBlocks = Array.from({ length: 4 }, (_, i) => paddedStudent.substring(i * 5, i * 5 + 5));

            let score = 0;
            const rowStatus = [];

            for (let i = 0; i < 4; i++) {
                const correctSet = [...correctBlocks[i].replace(/\s/g, "")].sort().join('').toUpperCase();
                const studentSet = [...studentBlocks[i].replace(/\s/g, "")].sort().join('').toUpperCase();

                if (correctSet === studentSet) {
                    score += 2;
                    rowStatus.push("correct");
                } else {
                    score -= 1;
                    rowStatus.push("wrong");
                }
            }

            return {
                score,
                studentBlocks,
                correctBlocks,
                rowStatus
            };
        }

        function compareMMAnswersExcel(correct, student) {
            const paddedCorrect = (correct || '').padEnd(20, ' ');
            const correctBlocks = Array.from({ length: 4 }, (_, i) => paddedCorrect.substring(i * 5, i * 5 + 5));

            let studentRawBlocks = (student || '').split('-').map(block => block.trim());

            const studentBlocks = Array.from({ length: 4 }, (_, i) => (studentRawBlocks[i] || '').padEnd(5, ' '));

            let score = 0;
            const rowStatus = [];

            for (let i = 0; i < 4; i++) {
                const correctSet = [...correctBlocks[i].replace(/\s/g, "")].sort().join('').toUpperCase();
                const studentSet = [...studentBlocks[i].replace(/\s/g, "")].sort().join('').toUpperCase();

                if (correctSet === studentSet) {
                    score += 2;
                    rowStatus.push("correct");
                } else {
                    score -= 1;
                    rowStatus.push("wrong");
                }
            }

            return {
                score,
                studentBlocks,
                correctBlocks,
                rowStatus
            };
        }

        function normalizeAnswerStringForComparison(value) {
            return String(value || '').replace(/[\s,]/g, '').toLowerCase().split('').sort().join('');
        }

        function normalizeNumericalValueForComparison(value) {
            let str = String(value || '').replace(/\s/g, '');
            if (str.startsWith('+')) {
                str = str.substring(1);
            }
            return parseFloat(str);
        }

        function calculatePartialMarks(studentAnswer, correctAnswer, rightMarks, negativeMarks, questionType, bonusMarks, currentExamType, selectedFormat) {
            if (bonusMarks > 0) return { marks: rightMarks, mmDetails: null, isCorrect: true, isAttempted: true, isPartiallyCorrect: false, isBonus: true };
            
            const studentAns = String(studentAnswer || '');

            if (studentAns.trim() === '' || studentAns.toLowerCase().trim() === 'x') {
                return { marks: 0, mmDetails: null, isCorrect: false, isAttempted: false, isPartiallyCorrect: false, isBonus: false };
            }

            const correctAns = String(correctAnswer);
            let marks = 0;
            let isCorrect = false;
            let isPartiallyCorrect = false;
            let mmDetails = null;

            switch(String(questionType || '').toUpperCase()) {
                case 'SC':
                case 'CS': // Added support for new question type
                case 'MC':
                case 'ML':
                    if (correctAns.includes(',')) {
                        const studentAnsUpper = studentAns.toUpperCase().trim();
                        const correctOptions = correctAns.split(',').map(opt => opt.trim().toUpperCase());
                        isCorrect = correctOptions.includes(studentAnsUpper);
                        marks = isCorrect ? rightMarks : -Math.abs(negativeMarks);
                    } else {
                        const normalizedStudentAns = normalizeAnswerStringForComparison(studentAns);
                        isCorrect = (normalizedStudentAns === correctAns);
                        marks = isCorrect ? rightMarks : -Math.abs(negativeMarks);
                    }
                    break;
                case 'MP':
                case 'CM': // Added support for new question type CM
                    const correctOptionsArrayMP = correctAns.split(',').map(opt => opt.trim().toUpperCase());
                    let maxScore = -Infinity;

                    correctOptionsArrayMP.forEach(singleCorrectAns => {
                        const correctOptionsMP = singleCorrectAns.split('').sort();
                        const studentOptionsMP = studentAns.toUpperCase().replace(/[\s,]/g, '').split('').sort();
                        
                        let currentMarks = 0;
                        let studentSelectedCorrectCount = 0;
                        let studentSelectedIncorrectOption = false;

                        for (const studentOpt of studentOptionsMP) {
                            if (!correctOptionsMP.includes(studentOpt)) {
                                studentSelectedIncorrectOption = true;
                                break;
                            }
                        }

                        if (studentSelectedIncorrectOption) {
                            currentMarks = -Math.abs(negativeMarks);
                        } else {
                            for (const studentOpt of studentOptionsMP) {
                                if (correctOptionsMP.includes(studentOpt)) {
                                    studentSelectedCorrectCount++;
                                }
                            }
                            if (studentSelectedCorrectCount === correctOptionsMP.length && studentOptionsMP.length === correctOptionsMP.length) {
                                currentMarks = rightMarks;
                            } else if (studentSelectedCorrectCount > 0) {
                                currentMarks = studentSelectedCorrectCount;
                            } else {
                                currentMarks = 0;
                            }
                        }
                        if (currentMarks > maxScore) {
                            maxScore = currentMarks;
                        }
                    });
                    marks = maxScore;
                    isCorrect = (marks === rightMarks);
                    isPartiallyCorrect = (marks > 0 && marks < rightMarks);
                    break;
                case 'ID':
                case 'IM':
                case 'SINT':
                case 'IS':
                    {
                        const studentNum = normalizeNumericalValueForComparison(studentAns);
                        let isCorrectLocal = false;

                        if (correctAns.includes('#')) {
                            const parts = correctAns.split('#');
                            const min = parseFloat(parts[0]);
                            const max = parseFloat(parts[1]);
                            if (!isNaN(studentNum) && studentNum >= min && studentNum <= max) {
                                isCorrectLocal = true;
                            }
                        } else if (correctAns.includes(',')) {
                            const correctOptions = correctAns.split(',').map(opt => normalizeNumericalValueForComparison(opt));
                            if (!isNaN(studentNum) && correctOptions.includes(studentNum)) {
                                isCorrectLocal = true;
                            }
                        } else {
                            const correctNum = normalizeNumericalValueForComparison(correctAns);
                            if (!isNaN(studentNum) && studentNum === correctNum) {
                                isCorrectLocal = true;
                            }
                        }

                        isCorrect = isCorrectLocal;
                        marks = isCorrect ? rightMarks : -Math.abs(negativeMarks);
                        isPartiallyCorrect = false;
                    }
                    break;
                case 'MM':
                    if (currentExamType === 'jee' && selectedFormat.includes('excel')) {
                        mmDetails = compareMMAnswersExcel(correctAns, studentAns);
                    } else {
                        mmDetails = compareMMAnswersDat(correctAns, studentAns);
                    }
                    let calculatedMMMarks = 0;
                    mmDetails.rowStatus.forEach(status => {
                        if (status === "correct") {
                            calculatedMMMarks += (rightMarks / 4);
                        } else {
                            if (negativeMarks > 0) {
                                calculatedMMMarks -= (negativeMarks / 4);
                            }
                        }
                    });
                    marks = calculatedMMMarks;
                    isCorrect = (marks === rightMarks);
                    isPartiallyCorrect = (marks > 0 && marks < rightMarks);
                    break;
                default:
                    const normalizedDefaultStudent = normalizeAnswerStringForComparison(studentAns);
                    const normalizedDefaultCorrect = normalizeAnswerStringForComparison(correctAns);
                    isCorrect = (normalizedDefaultStudent === normalizedDefaultCorrect);
                    marks = isCorrect ? rightMarks : -Math.abs(negativeMarks);
                    isPartiallyCorrect = false;
            }
            return { marks, mmDetails, isCorrect, isAttempted: true, isPartiallyCorrect: isPartiallyCorrect, isBonus: false };
        }

        function calculateMarksForObjectiveStudent(student, questionColumnsToProcess, selectedFormat) {
            const result = {
                frmid: student['frmid'],
                total: 0,
                marks_by_subject: {},
                marks_by_question_type: {},
                mm_question_details: {},
                correct_count: 0,
                incorrect_count: 0,
                left_count: 0
            };
            uniqueQuestionTypes.forEach(type => { result.marks_by_question_type[`${String(type || '').toLowerCase()}_total`] = 0; });

            result.question_correctness = {};
            result.question_partial_correctness = {};
            result.question_is_bonus = {};
            result.student_responses_processed = {};

            questionColumnsToProcess.forEach(qKey => {
                const scheme = markingScheme[qKey];
                let marksForQuestion = 0;
                let isCorrect = false;
                let isAttempted = false;
                let isPartiallyCorrect = false;
                let isBonus = false;
                let mmDetails = null;

                if (scheme) {
                    const calculated = calculatePartialMarks(
                        student[qKey],
                        scheme.correctAnswer,
                        scheme.rightMarks,
                        scheme.negativeMarks,
                        scheme.questionType,
                        scheme.bonus,
                        currentExamType,
                        selectedFormat
                    );
                    marksForQuestion = calculated.marks;
                    isCorrect = calculated.isCorrect;
                    isAttempted = calculated.isAttempted;
                    isPartiallyCorrect = calculated.isPartiallyCorrect;
                    isBonus = calculated.isBonus;
                    mmDetails = calculated.mmDetails;

                    if (isBonus || isCorrect || isPartiallyCorrect) {
                        result.correct_count++;
                    } else if (isAttempted) {
                        result.incorrect_count++;
                    } else {
                        result.left_count++;
                    }

                    if (mmDetails) result.mm_question_details[qKey] = { mmResult: mmDetails };
                    
                    result.marks_by_question_type[`${String(scheme.questionType || '').toLowerCase()}_total`] += marksForQuestion;
                    result.marks_by_subject[scheme.subject] = (result.marks_by_subject[scheme.subject] || 0) + marksForQuestion;

                    let displayValue = student[qKey] || '';
                    if (isAttempted) {
                        if (['id', 'im', 'sint', 'is'].includes(String(scheme.questionType || '').toLowerCase())) {
                            let numVal = normalizeNumericalValueForComparison(displayValue);
                            displayValue = isNaN(numVal) ? (displayValue || '') : (numVal.toFixed(2));
                        }
                    }
                    result.student_responses_processed[qKey] = displayValue;

                } else {
                    marksForQuestion = 0;
                    isCorrect = false;
                    isAttempted = false;
                    isPartiallyCorrect = false;
                    isBonus = false;
                    result.student_responses_processed[qKey] = student[qKey] || '';
                }
                result[qKey] = marksForQuestion;
                result.total += marksForQuestion;
                result.question_correctness[qKey] = isCorrect;
                result.question_partial_correctness[qKey] = isPartiallyCorrect;
                result.question_is_bonus[qKey] = isBonus;
            });
            return result;
        }
        
        /** Main Processing Function (Combined Objective & Subjective) **/

        async function startProcessing() {
            hideModal();
            toggleSpinner(true);
            validationMessages = [];
            
            if (currentExamType === 'subjective') {
                await processSubjectiveFiles();
            } else {
                await processObjectiveFiles();
            }
        }

        async function processObjectiveFiles() {
            const files = { file1: file1Input.files[0], file2: file2Input.files[0], file3: file3Input.files[0] };
            if (!files.file1 || !files.file2) {
                showModal('Error', 'Please upload both the Marking Scheme and Student Responses files.', 'error');
                toggleSpinner(false);
                return;
            }

            try {
                let originalStudentResponses = [];
                const file1Extension = files.file1.name.split('.').pop().toLowerCase();
                const selectedFormat = formatSelector.value;
                
                if (selectedFormat === 'jee_dat_cbt') {
                    currentExamType = 'jee';
                    if (file1Extension !== 'dat') {
                        throw new Error(`The selected format is 'JEE DAT', but the uploaded file is not a .dat file. Please upload a .dat file or change the format selection.`);
                    }
                    originalStudentResponses = await readJeeDatFile(files.file1);
                } else if (selectedFormat === 'jee_excel') {
                    currentExamType = 'jee';
                    if (!['xlsx', 'xls', 'csv'].includes(file1Extension)) {
                        throw new Error(`The selected format is 'JEE Excel', but the uploaded file is not an Excel/CSV file. Please upload an .xls, .xlsx, or .csv file or change the format selection.`);
                    }
                    originalStudentResponses = await readExcelFile(files.file1, true);
                } else if (selectedFormat === 'neet_other') {
                    currentExamType = 'neet';
                    if (file1Extension === 'dat') {
                        originalStudentResponses = await readNeetDatFile(files.file1);
                    } else if (['xlsx', 'xls', 'csv'].includes(file1Extension)) {
                        originalStudentResponses = await readExcelFile(files.file1, true);
                    } else {
                        throw new Error("The student response file format for NEET/Other is unsupported. Please upload a .dat, .xls, .xlsx, or .csv file.");
                    }
                } else {
                    throw new Error("An invalid student response file format was selected. Please choose a valid format from the dropdown.");
                }

                if (originalStudentResponses.length === 0) throw new Error("The student response file is empty or invalid.");
                
                let rawMarkingSchemeData = await readExcelFile(files.file2);
                if (rawMarkingSchemeData.length === 0) throw new Error("The marking scheme file is empty or invalid.");

                if (currentExamType === 'jee') {
                    const sectionTypeMapping = {
                        '1': ['MP', 'SC', 'MC', 'ML', 'CS', 'CM'], // Updated to include both 'CS' and 'CM'
                        '2': ['ID', 'IM'],
                        '3': ['IS'],
                        '4': ['MM']
                    };

                    rawMarkingSchemeData.forEach(row => {
                        const section = String(row['section'] || '').trim().replace('SECTION ', '');
                        const qType = String(row['ques type'] || '').trim().toUpperCase();
                        const qNo = String(row['que.no.'] || '');

                        if (section && qType && sectionTypeMapping[section]) {
                            if (!sectionTypeMapping[section].includes(qType)) {
                                validationMessages.push(
                                    `<b>Error in Marking Scheme:</b> Question number <b>${qNo}</b> in section <b>${section}</b> has an invalid type '<b>${qType}</b>'. The allowed types for this section are: ${sectionTypeMapping[section].join(', ')}.`
                                );
                            }
                        }
                    });
                }

                const criticalErrors = validationMessages.filter(msg => msg.startsWith("<b>Error:"));
                if (criticalErrors.length > 0) {
                    throw new Error(criticalErrors.join('<br>'));
                }


                let originalMarkingSchemeByQNo = new Map();
                rawMarkingSchemeData.forEach(row => {
                    const qNo = parseInt(row['que.no.']);
                    if (!isNaN(qNo)) {
                        originalMarkingSchemeByQNo.set(qNo, row);
                    }
                });

                let studentDataToCalculate = [];
                let finalMarkingScheme = {};
                
                uniqueSubjects = [];
                uniqueQuestionTypes = [];
                maxMarksBySubject = {};
                overallMaxMarks = 0;
                
                const maxQuestionsFromMarkingScheme = rawMarkingSchemeData.length;
                for (let i = 0; i < maxQuestionsFromMarkingScheme; i++) {
                    const qNoInScheme = i + 1;
                    const newQKey = `f${String(qNoInScheme).padStart(3, '0')}`;

                    const schemeEntry = originalMarkingSchemeByQNo.get(qNoInScheme);

                    if (!schemeEntry) {
                        throw new Error(`Entry for question number ${qNoInScheme} is missing in the marking scheme. Please ensure the marking scheme file has entries for all expected question numbers from 1 to ${maxQuestionsFromMarkingScheme}.`);
                    }

                    const subject = String(schemeEntry['subject'] || '').trim().toUpperCase();
                    const rightMarks = parseFloat(schemeEntry['right marks'] || 0);
                    const qType = String(schemeEntry['ques type'] || '').trim().toUpperCase();
                    let section = String(schemeEntry['section'] || '').trim().toUpperCase();
                    if (section.match(/^\d+$/)) {
                        section = `SECTION ${section}`;
                    }

                    let correctAnswerValue = String(schemeEntry['correct answer'] || '');

                    if (qType === 'MM') {
                        correctAnswerValue = correctAnswerValue.padEnd(20, ' ').substring(0, 20);
                    } else if (['sc', 'cs', 'mc', 'mp', 'ml'].includes(qType.toLowerCase())) {
                        if (!correctAnswerValue.includes(',')) {
                            correctAnswerValue = normalizeAnswerStringForComparison(correctAnswerValue);
                        } else {
                            correctAnswerValue = correctAnswerValue.trim();
                        }
                    } else {
                        correctAnswerValue = correctAnswerValue.trim();
                    }

                    finalMarkingScheme[newQKey] = {
                        questionType: qType,
                        correctAnswer: correctAnswerValue,
                        rightMarks: rightMarks,
                        negativeMarks: parseFloat(schemeEntry['negative marks'] || 0),
                        bonus: parseFloat(schemeEntry['bonus'] || 0),
                        subject: subject,
                        section: section,
                        relativeQNoInSubject: qNoInScheme
                    };

                    maxMarksBySubject[subject] = (maxMarksBySubject[subject] || 0) + rightMarks;
                    overallMaxMarks += rightMarks;
                    if (subject && !uniqueSubjects.includes(subject)) uniqueSubjects.push(subject);
                    if (qType && !uniqueQuestionTypes.includes(qType)) uniqueQuestionTypes.push(qType);
                }
                
                markingScheme = finalMarkingScheme;
                questionColumns = Object.keys(markingScheme).sort((a, b) => parseInt(a.substring(1)) - parseInt(b.slice(1)));
                if (questionColumns.length === 0) throw new Error('No valid questions found in the marking scheme after processing.');

                uniqueSubjects.sort((a,b) => (PREDEFINED_SUBJECT_ORDER.indexOf(a) || 99) - (PREDEFINED_SUBJECT_ORDER.indexOf(b) || 99));

                if (currentExamType === 'jee') {
                    const reindexedMapping = {};
                    const subjectsInKey = [...new Set(rawMarkingSchemeData.map(q => String(q['subject'] || '').trim().toUpperCase()).filter(Boolean))];
                    const subjectIndexMap = Object.fromEntries(subjectsInKey.map((s, i) => [s, i + 1]));

                    let expectedOriginalFColumns = [];
                    Object.keys(subjectIndexMap).forEach(subjectName => {
                        const subjectNumber = subjectIndexMap[subjectName];
                        const sectionsForSubject = rawMarkingSchemeData.filter(row => String(row['subject'] || '').trim().toUpperCase() === subjectName)
                            .map(row => {
                                let section = String(row['section'] || '').trim().toUpperCase();
                                if (section.match(/^\d+$/)) { section = `SECTION ${section}`; }
                                return section;
                            }).filter((value, index, self) => self.indexOf(value) === index);

                        sectionsForSubject.forEach(section => {
                            const count = rawMarkingSchemeData.filter(row =>
                                String(row['subject'] || '').trim().toUpperCase() === subjectName &&
                                (String(row['section'] || '').trim().toUpperCase() === section || (String(row['section'] || '').match(/^\d+$/) && `SECTION ${String(row['section'] || '').trim().toUpperCase()}` === section))
                            ).length;
                            const columns = {
                                1: { 'SECTION 1': Array.from({length: 20}, (_, i) => i + 1), 'SECTION 2': Array.from({length: 10}, (_, i) => i + 21), 'SECTION 3': Array.from({length: 10}, (_, i) => i + 31), 'SECTION 4': Array.from({length: 2}, (_, i) => i + 41) },
                                2: { 'SECTION 1': Array.from({length: 20}, (_, i) => i + 43), 'SECTION 2': Array.from({length: 10}, (_, i) => i + 63), 'SECTION 3': Array.from({length: 10}, (_, i) => i + 73), 'SECTION 4': Array.from({length: 2}, (_, i) => i + 83) },
                                3: { 'SECTION 1': Array.from({length: 20}, (_, i) => i + 85), 'SECTION 2': Array.from({length: 10}, (_, i) => i + 105), 'SECTION 3': Array.from({length: 10}, (_, i) => i + 115), 'SECTION 4': Array.from({length: 2}, (_, i) => i + 125) }
                            }[subjectNumber][section];
                            expectedOriginalFColumns.push(...columns.slice(0, count));
                        });
                    });
                    expectedOriginalFColumns.sort((a,b) => a - b);

                    expectedOriginalFColumns.forEach((colNum, idx) => {
                        const originalCol = `f${String(colNum).padStart(3, '0')}`;
                        const newCol = `f${String(idx + 1).padStart(3, '0')}`;
                        reindexedMapping[originalCol] = newCol;
                    });

                    studentDataToCalculate = originalStudentResponses.map(originalRow => {
                        const newRow = { frmid: originalRow.frmid };
                        questionColumns.forEach(newQKey => {
                            const originalCol = Object.keys(reindexedMapping).find(key => reindexedMapping[key] === newQKey);
                            if (originalCol && originalRow[originalCol] !== undefined) {
                                newRow[newQKey] = originalRow[originalCol];
                            } else {
                                newQKey = '';
                            }
                        });
                        return newRow;
                    });
                } else {
                    studentDataToCalculate = originalStudentResponses;
                }

                studentData = studentDataToCalculate;

                if (files.file3) {
                    const details = await readExcelFile(files.file3);
                    details.forEach(d => {
                        let detailFrmid = String(d['frmid'] || '').trim();
                        if (!isNaN(parseFloat(detailFrmid)) && isFinite(detailFrmid)) {
                            detailFrmid = String(parseInt(detailFrmid, 10));
                        }
                        if (detailFrmid) studentDetailsMap.set(detailFrmid.toLowerCase(), { studentName: String(d['student name'] || ''), batch: String(d['batch'] || '') });
                    });
                }
                
                if (uniqueSubjects.length > 1) { // Only show if more than one subject
                    showRankingModal(uniqueSubjects, 'objective');
                } else {
                    rankingCriteria = []; // Reset criteria
                    performObjectiveCalculationsAndRender();
                }
            } catch (error) {
                showModal('Error', `Error: ${error.message}`, 'error');
                toggleSpinner(false);
            }
        }

        function performObjectiveCalculationsAndRender() {
            const selectedFormat = formatSelector.value;
            calculatedResults = studentData.map(student => calculateMarksForObjectiveStudent(student, questionColumns, selectedFormat));
            
            // NEW: Calculate overall statistics
            calculateOverallStats(calculatedResults.map(r => r.total));

            renderObjectiveResults();

            if (validationMessages.length > 0) {
                showModal('Warning', validationMessages.join('<br>'), 'warning', 5000);
            } else {
                showModal('Success', 'Results successfully generated!', 'success', 3000);
            }
            toggleSpinner(false);
        }

        async function processSubjectiveFiles() {
            const subjectiveMarksFile = subjectiveFile.files[0];
            const subjectiveDetailsOptionalFile = subjectiveDetailsFile.files[0];

            if (!subjectiveMarksFile) {
                showModal('Error', 'Please upload the subjective marks file.', 'error');
                toggleSpinner(false);
                return;
            }

            try {
                const rawData = await readExcelFile(subjectiveMarksFile);
                if (rawData.length === 0) throw new Error("The subjective marks file is empty or invalid.");

                studentData = rawData;
                maxMarksBySubject = {};
                overallMaxMarks = 0;
                uniqueSubjects = [];
                studentDetailsMap.clear();

                if (subjectiveDetailsOptionalFile) {
                    const details = await readExcelFile(subjectiveDetailsOptionalFile);
                    details.forEach(d => {
                        let detailFrmid = String(d['frmid'] || '').trim();
                        if (detailFrmid) studentDetailsMap.set(detailFrmid.toLowerCase(), { studentName: String(d['student name'] || ''), batch: String(d['batch'] || '') });
                    });
                }
                
                const firstRowHeaders = Object.keys(rawData[0]).map(h => h.trim().toLowerCase());
                const subjectKeys = firstRowHeaders.filter(h => h !== 'frmid' && h !== 'student name' && h !== 'batch' && !h.includes('max marks'));

                subjectKeys.forEach(subjectKey => {
                    const maxMarksKey = `${subjectKey} max marks`;
                    // Fixed: Only consider the max marks from the first row if present, otherwise assume max marks are not provided in the file.
                    const maxMarks = (rawData.length > 0 && rawData[0][maxMarksKey] !== undefined) ? parseFloat(rawData[0][maxMarksKey]) : 0;
                    if (!isNaN(maxMarks) && maxMarks > 0) {
                        uniqueSubjects.push(subjectKey);
                        maxMarksBySubject[subjectKey] = maxMarks;
                        overallMaxMarks += maxMarks;
                    }
                });

                // Fixed: Populate student details from the raw data if not provided in a separate file.
                studentData = rawData.map(row => {
                    const frmid = String(row['frmid'] || '').trim().toLowerCase();
                    const studentName = studentDetailsMap.get(frmid)?.studentName || row['student name'] || '';
                    const batch = studentDetailsMap.get(frmid)?.batch || row['batch'] || '';
                    return { ...row, frmid: row['frmid'], 'student name': studentName, 'batch': batch };
                });
                
                if (uniqueSubjects.length > 1) {
                    showRankingModal(uniqueSubjects, 'subjective');
                } else if (uniqueSubjects.length === 1) {
                    rankingCriteria = uniqueSubjects;
                    performSubjectiveCalculationsAndRender();
                } else {
                    throw new Error("No valid subjects found in the subjective marks file. Please check the column headers.");
                }

            } catch (error) {
                showModal('Error', `Error: ${error.message}`, 'error');
                toggleSpinner(false);
            }
        }

        function performSubjectiveCalculationsAndRender() {
            calculatedResults = studentData.map(row => {
                const frmid = String(row['frmid'] || '').trim().toLowerCase();
                const result = {
                    frmid: row['frmid'],
                    studentName: studentDetailsMap.get(frmid)?.studentName || row['student name'] || '',
                    batch: studentDetailsMap.get(frmid)?.batch || row['batch'] || '',
                    total_marks: 0,
                    marks_by_subject: {},
                };
                uniqueSubjects.forEach(subKey => {
                    const marks = parseFloat(row[subKey] || 0);
                    result.marks_by_subject[subKey] = isNaN(marks) ? 0 : marks;
                    result.total_marks += result.marks_by_subject[subKey];
                });
                result.percentage = overallMaxMarks > 0 ? (result.total_marks / overallMaxMarks) * 100 : 0;
                return result;
            });
            
            // NEW: Calculate overall statistics
            calculateOverallStats(calculatedResults.map(r => r.total_marks));

            renderSubjectiveResults();
            showModal('Success', 'Subjective results successfully generated!', 'success', 3000);
            toggleSpinner(false);
        }

        function formatNumberToTwoDecimals(num, keepTrailingZeros = false) {
            if (typeof num === 'number' && !isNaN(num)) {
                if (keepTrailingZeros) {
                    return num.toFixed(2);
                } else {
                    const fixedNum = num.toFixed(2);
                    if (fixedNum.endsWith('.00')) {
                        return String(parseInt(fixedNum));
                    }
                    return fixedNum;
                }
            }
            return 'x';
        }

        function formatDateToDdMmmYyyy(dateStr) {
            if (!dateStr) return '';
            const date = new Date(dateStr);
            const options = { day: '2-digit', month: 'short', year: 'numeric' };
            return date.toLocaleDateString('en-GB', options).replace(/ /g, '-');
        }

        /** Rendering Functions (Combined) **/
        function renderObjectiveResults() {
            const testName = testNameInput.value.trim();
            const testDate = testDateInput.value ? formatDateToDdMmmYyyy(testDateInput.value) : '';
            
            summaryResultsDiv.innerHTML = '';
            resultsContainer.style.display = 'block';
            // Show all tabs for objective tests
            resultsTabsContainer.style.display = 'flex';
            document.querySelectorAll('#resultsTabsContainer .results-tab-btn').forEach(btn => btn.style.display = 'flex');
            
            calculatedResults.sort((a, b) => {
                if (b.total !== a.total) {
                    return b.total - a.total;
                }
                if (rankingCriteria && rankingCriteria.length > 0) {
                    for (const subject of rankingCriteria) {
                        const subjectKey = subject.toLowerCase();
                        if (b.marks_by_subject[subjectKey] !== a.marks_by_subject[subjectKey]) {
                            return b.marks_by_subject[subjectKey] - a.marks_by_subject[subjectKey];
                        }
                    }
                }
                const fnoA = parseInt(a.frmid) || 0;
                const fnoB = parseInt(b.frmid) || 0;
                return fnoA - fnoB;
            });

            const totalStudents = calculatedResults.length;
            summaryResults = calculatedResults.map((res, i) => {
                const studentDetail = studentDetailsMap.get(String(res.frmid || '').trim().toLowerCase()) || {};
                const originalStudent = studentData.find(s => String(s.frmid || '').trim().toLowerCase() === String(res.frmid || '').trim().toLowerCase()) || {};
                const rank = i + 1;
                const percentile = (totalStudents > 0)
                    ? (((totalStudents - (rank - 1)) / totalStudents) * 100)
                    : 0;

                const summary = {
                    'Sno.': i + 1,
                    'Fno.': res.frmid,
                    'Student Name': studentDetail.studentName || originalStudent['student name'] || '',
                    'Batch': studentDetail.batch || originalStudent['batch'] || '',
                    total_marks: res.total,
                    correct_count: res.correct_count,
                    incorrect_count: res.incorrect_count,
                    left_count: res.left_count,
                    rank: rank,
                    percentile: percentile.toFixed(2)
                };
                
                const orderedSubjects = [...uniqueSubjects].sort((a,b) => (PREDEFINED_SUBJECT_ORDER.indexOf(a) || 99) - (PREDEFINED_SUBJECT_ORDER.indexOf(b) || 99));
                orderedSubjects.forEach(sub => {
                    const marks = res.marks_by_subject[sub] || 0;
                    summary[`marks_${sub.toLowerCase()}`] = marks;
                });
                summary['percentage'] = overallMaxMarks > 0 ? ((res.total / overallMaxMarks) * 100) : 0;
                
                return summary;
            });
            
            renderObjectiveSummaryTable(testName, testDate);
            renderDetailedResultsTable();
            renderResponseAnalysisTable();

            // *** NEW: Switch to summary tab after rendering ***
            document.querySelectorAll('.results-tab-btn').forEach(b => b.classList.remove('active'));
            document.querySelectorAll('.results-tab-content').forEach(content => content.classList.remove('active'));
            document.querySelector('.results-tab-btn[data-tab="summaryResults"]').classList.add('active');
            document.getElementById('summaryResults').classList.add('active');
        }
        
        function renderObjectiveSummaryTable(testName, testDate) {
            const headerHtml = `
                <div class="results-header">
                    <div class="results-header-title">
                        <h2>Test Results</h2>
                        <p>${testName} | ${testDate}</p>
                    </div>
                    <div id="downloadButtons" class="download-buttons-container">
                        <div id="objectiveDownloadButtons" style="display: flex; gap: 1rem;">
                            <div style="position: relative;">
                                <button id="downloadSummaryExcelBtn" class="btn-download">Download Result (Excel)</button>
                                <div id="excelDropdown" class="dropdown-menu">
                                    <a href="#" class="dropdown-item" data-type="excel" data-rank="with">With Rank</a>
                                    <a href="#" class="dropdown-item" data-type="excel" data-rank="without">Without Rank</a>
                                </div>
                            </div>
                            <div style="position: relative;">
                                <button id="downloadSummaryPdfBtn" class="btn-download">Download Result (PDF)</button>
                                <div id="pdfDropdown" class="dropdown-menu">
                                    <a href="#" class="dropdown-item" data-type="pdf" data-rank="with">With Rank</a>
                                    <a href="#" class="dropdown-item" data-type="pdf" data-rank="without">Without Rank</a>
                                </div>
                            </div>
                            <button id="generatePdfBtn" class="btn-download">Generate Student PDF</button>
                        </div>
                    </div>
                </div>
            `;
            summaryResultsDiv.innerHTML = headerHtml;

            // NEW: Add stats container
            const statsContainer = document.createElement('div');
            statsContainer.id = 'summaryStatsContainer';
            summaryResultsDiv.appendChild(statsContainer);
            renderStats();

            const orderedSubjects = [...uniqueSubjects].sort((a,b) => (PREDEFINED_SUBJECT_ORDER.indexOf(a) || 99) - (PREDEFINED_SUBJECT_ORDER.indexOf(b) || 99));

            let overallColSpan = 2; // for %age and %tile
            if (uniqueSubjects.length > 1) overallColSpan++; // for Total
            if (summaryResults.every(r => r.rank)) overallColSpan++; // for Rank

            const headerGroups = [
                { name: 'Student Info', span: 4 },
                { name: 'Attempted', span: 3 },
                { name: 'Subject Scores', span: orderedSubjects.length },
                { name: 'Overall Score & Rank', span: overallColSpan }
            ].filter(g => g.span > 0);

            const subHeaders = ['Sno.', 'Fno.', 'Student Name', 'Batch', 'Correct', 'Wrong', 'Left', ...orderedSubjects.map(s => `${SUBJECT_SHORT_NAMES[s] || s} (${formatNumberToTwoDecimals(maxMarksBySubject[s] || 0)})`)];
            if (uniqueSubjects.length > 1) subHeaders.push(`Total (${formatNumberToTwoDecimals(overallMaxMarks)})`);
            subHeaders.push('%age', '%tile', 'Rank');

            const tableWrapper = document.createElement('div');
            tableWrapper.className = 'table-wrapper';
            tableWrapper.innerHTML = `<table class="summary-table" id="summaryTable"></table>`;
            const paginationWrapper = document.createElement('div');
            paginationWrapper.id = 'summaryPagination';

            summaryResultsDiv.appendChild(tableWrapper);
            summaryResultsDiv.appendChild(paginationWrapper);

            renderTableWithPagination('summaryTable', 'summaryPagination', summaryResults, 10, (row) => {
                let html = `<td class="sticky-col">${row['Sno.']}</td>
                                        <td>${row['Fno.']}</td>
                                        <td style="text-align: left;">${row['Student Name']}</td>
                                        <td>${row['Batch']}</td>
                                        <td class="correct-count-cell">${row.correct_count}</td>
                                        <td class="incorrect-count-cell">${row.incorrect_count}</td>
                                        <td class="left-count-cell">${row.left_count}</td>`;
                orderedSubjects.forEach(sub => {
                    html += `<td>${formatNumberToTwoDecimals(row[`marks_${sub.toLowerCase()}`])}</td>`;
                });
                
                if (uniqueSubjects.length > 1) {
                    html += `<td>${formatNumberToTwoDecimals(row.total_marks)}</td>`;
                }
                
                html += `<td>${row.percentage.toFixed(2)}</td>
                                        <td>${row.percentile}</td>
                                        <td>${row.rank}</td>`;
                return html;
            }, () => subHeaders, headerGroups);
            
            // Re-attach event listeners for download buttons
            document.getElementById('downloadSummaryExcelBtn').addEventListener('click', (event) => { 
                event.stopPropagation(); 
                document.getElementById('excelDropdown')?.classList.toggle('show');
            });
            document.getElementById('downloadSummaryPdfBtn').addEventListener('click', (event) => { 
                event.stopPropagation(); 
                document.getElementById('pdfDropdown')?.classList.toggle('show');
            });
            document.getElementById('generatePdfBtn').addEventListener('click', generateStudentPdfs);
            
            document.getElementById('excelDropdown')?.querySelectorAll('.dropdown-item').forEach(item => {
                item.addEventListener('click', (event) => {
                    event.preventDefault();
                    const includeRank = event.target.dataset.rank === 'with';
                    downloadObjectiveResults(includeRank, 'excel');
                    document.getElementById('excelDropdown').classList.remove('show');
                });
            });

            document.getElementById('pdfDropdown')?.querySelectorAll('.dropdown-item').forEach(item => {
                item.addEventListener('click', (event) => {
                    event.preventDefault();
                    const includeRank = event.target.dataset.rank === 'with';
                    downloadObjectiveResults(includeRank, 'pdf');
                    document.getElementById('pdfDropdown').classList.remove('show');
                });
            });
        }

        function renderSubjectiveResults() {
            const testName = testNameInput.value.trim();
            const testDate = testDateInput.value ? formatDateToDdMmmYyyy(testDateInput.value) : '';

            summaryResultsDiv.innerHTML = '';
            resultsContainer.style.display = 'block';
            
            // *** MODIFICATION FOR SUBJECTIVE TABS ***
            // Show tab container but hide irrelevant tabs
            resultsTabsContainer.style.display = 'flex';
            document.querySelector('.results-tab-btn[data-tab="summaryResults"]').style.display = 'flex';
            document.querySelector('.results-tab-btn[data-tab="detailedResults"]').style.display = 'none';
            document.querySelector('.results-tab-btn[data-tab="responseAnalysis"]').style.display = 'none';
            
            calculatedResults.sort((a, b) => {
                if (b.total_marks !== a.total_marks) {
                    return b.total_marks - a.total_marks;
                }
                for (const subject of rankingCriteria) {
                    const marksA = a.marks_by_subject[subject] || 0;
                    const marksB = b.marks_by_subject[subject] || 0;
                    if (marksB !== marksA) {
                        return marksB - marksA;
                    }
                }
                const fnoA = parseInt(a.frmid) || 0;
                const fnoB = parseInt(b.frmid) || 0;
                return fnoA - fnoB;
            });
            
            calculatedResults.forEach((res, index) => {
                res.rank = index + 1;
            });

            const headerHtml = `
                <div class="results-header">
                    <div class="results-header-title">
                        <h2>Subjective Test Results</h2>
                        <p>${testName} | ${testDate}</p>
                    </div>
                    <div id="downloadButtons" class="download-buttons-container">
                        <div id="subjectiveDownloadButtons" style="display: flex; gap: 1rem;">
                            <button id="downloadSubjectiveExcelBtn" class="btn-download">Download Result (Excel)</button>
                            <button id="downloadSubjectivePdfBtn" class="btn-download">Download Result (PDF)</button>
                        </div>
                    </div>
                </div>
            `;
            summaryResultsDiv.innerHTML = headerHtml;

            // NEW: Add stats container
            const statsContainer = document.createElement('div');
            statsContainer.id = 'summaryStatsContainer';
            summaryResultsDiv.appendChild(statsContainer);
            renderStats();
            
            const headers = [['Sno.', 'Fno.', 'Student Name', 'Batch', ...uniqueSubjects.map(s => `${s} (${formatNumberToTwoDecimals(maxMarksBySubject[s])})`), `Total Marks (${formatNumberToTwoDecimals(overallMaxMarks)})`, '%age', 'Rank']];
            
            const tableWrapper = document.createElement('div');
            tableWrapper.className = 'table-wrapper';
            tableWrapper.innerHTML = `<table class="summary-table" id="summaryTable"></table>`;
            const paginationWrapper = document.createElement('div');
            paginationWrapper.id = 'summaryPagination';

            summaryResultsDiv.appendChild(tableWrapper);
            summaryResultsDiv.appendChild(paginationWrapper);

            renderTableWithPagination('summaryTable', 'summaryPagination', calculatedResults, 10, (row, index) => {
                                        let html = `<td class="sticky-col">${index + 1}</td>
                                                                    <td>${row.frmid}</td>
                                                                    <td style="text-align: left;">${row.studentName}</td>
                                                                    <td>${row.batch}</td>`;
                                        uniqueSubjects.forEach(sub => {
                                            html += `<td>${formatNumberToTwoDecimals(row.marks_by_subject[sub])}</td>`;
                                        });
                                        html += `<td>${formatNumberToTwoDecimals(row.total_marks)}</td>
                                                                         <td>${row.percentage.toFixed(2)}</td>
                                                                         <td>${row.rank}</td>`;
                                        return html;
            }, () => headers[0]);

            // Re-attach event listeners
            document.getElementById('downloadSubjectiveExcelBtn').addEventListener('click', downloadSubjectiveExcel);
            document.getElementById('downloadSubjectivePdfBtn').addEventListener('click', downloadSubjectivePdf);
            
            // *** NEW: Switch to summary tab after rendering ***
            document.querySelectorAll('.results-tab-btn').forEach(b => b.classList.remove('active'));
            document.querySelectorAll('.results-tab-content').forEach(content => content.classList.remove('active'));
            document.querySelector('.results-tab-btn[data-tab="summaryResults"]').classList.add('active');
            document.getElementById('summaryResults').classList.add('active');
        }
        
        function generateGrid(blocks, status, isPdf = false) {
            const headers = ['P', 'Q', 'R', 'S', 'T'];
            let html = '<table class="grid-table">';
            html += '<tr><th></th>' + headers.map(h => `<th>${h}</th>`).join('') + '</tr>';
            ['A','B','C','D'].forEach((rowLabel, i) => {
                const values = (blocks[i] || '').padEnd(5, ' ').split('');
                const cellClass = isPdf ? '' : status[i];
                html += `<tr><th>${rowLabel}</th>` + values.map((v) => `<td class="${cellClass}">${v.trim()}</td>`).join('') + '</tr>';
            });
            html += '</table>';
            return html;
        }

        function renderDetailedResultsTable() {
            if (calculatedResults.length === 0 || currentExamType === 'subjective') {
                detailedResultsDiv.innerHTML = '';
                return;
            }
            
            detailedResultsDiv.innerHTML = `
                <div class="results-tab-header">
                    <h3>Detailed Marks Analysis</h3>
                    <button id="downloadDetailedBtn" class="btn-download" style="font-size: 14px; padding: 8px 16px;">Download Excel</button>
                </div>
                <div class="table-wrapper">
                    <table class="results-table" id="detailedTable"></table>
                </div>
                <div id="detailedPagination"></div>
            `;
            
            renderTableWithPagination('detailedTable', 'detailedPagination', calculatedResults, 10, (rowData) => {
                const sortedQuestionColumns = [...questionColumns].sort((a, b) => parseInt(a.slice(1)) - parseInt(b.slice(1)));
                const questionHeaders = sortedQuestionColumns.map(qKey => {
                    const questionInfo = markingScheme[qKey];
                    const originalQNo = questionInfo ? questionInfo.relativeQNoInSubject : parseInt(qKey.slice(1));
                    return { key: qKey, text: `F${String(originalQNo).padStart(3, '0')}` };
                });
                const questionTypeTotalHeaders = uniqueQuestionTypes.sort();

                let rowHtml = `<td class="sticky-col">${rowData.frmid}</td>
                                                                    <td>${rowData.correct_count}</td>
                                                                    <td>${rowData.incorrect_count}</td>
                                                                    <td>${rowData.left_count}</td>`;
                
                questionTypeTotalHeaders.forEach(type => {
                    const typeKey = `${type.toLowerCase()}_total`;
                    rowHtml += `<td>${formatNumberToTwoDecimals(rowData.marks_by_question_type[typeKey])}</td>`;
                });

                questionHeaders.forEach(({ key: qKey }) => {
                    let cellClass = '';
                    let cellContent = formatNumberToTwoDecimals(rowData[qKey]);
                    if (rowData.question_is_bonus[qKey]) {
                        cellClass = 'bonus-answer-cell';
                        cellContent = 'B';
                    } else if (rowData.question_correctness[qKey]) {
                        cellClass = 'correct-answer-cell';
                    } else if (rowData.question_partial_correctness[qKey]) {
                        cellClass = 'partially-correct-cell';
                    } else if (rowData.student_responses_processed[qKey] && String(rowData.student_responses_processed[qKey] || '').toLowerCase() !== 'x') {
                        cellClass = 'wrong-answer-cell';
                    }
                    rowHtml += `<td class="${cellClass}">${cellContent}</td>`;
                });

                rowHtml += `<td>${formatNumberToTwoDecimals(rowData.total)}</td>`;
                return rowHtml;
            }, () => {
                    const sortedQuestionColumns = [...questionColumns].sort((a, b) => parseInt(a.slice(1)) - parseInt(b.slice(1)));
                    const questionHeaders = sortedQuestionColumns.map(qKey => `F${String(markingScheme[qKey].relativeQNoInSubject).padStart(3, '0')}`);
                    const questionTypeTotalHeaders = uniqueQuestionTypes.sort().map(type => `${type} Total`);
                    return ['FRMID', 'Correct', 'Wrong', 'Left', ...questionTypeTotalHeaders, ...questionHeaders, 'Total'];
            });

            document.getElementById('downloadDetailedBtn').addEventListener('click', () => downloadDataAsExcel(calculatedResults, 'Detailed_Results.xlsx', (rowData) => {
                const sortedQuestionColumns = [...questionColumns].sort((a, b) => parseInt(a.slice(1)) - parseInt(b.slice(1)));
                const questionHeaders = sortedQuestionColumns.map(qKey => `F${String(markingScheme[qKey].relativeQNoInSubject).padStart(3, '0')}`);
                const questionTypeTotalHeaders = uniqueQuestionTypes.sort().map(type => `${type} Total`);
                const headers = ['FRMID', 'Correct', 'Wrong', 'Left', ...questionTypeTotalHeaders, ...questionHeaders, 'Total'];
                
                const row = {
                    'FRMID': rowData.frmid,
                    'Correct': rowData.correct_count,
                    'Wrong': rowData.incorrect_count,
                    'Left': rowData.left_count,
                    'Total': rowData.total
                };
                questionTypeTotalHeaders.forEach(typeHeader => {
                    const typeKey = typeHeader.replace(' Total', '').toLowerCase() + '_total';
                    row[typeHeader] = rowData.marks_by_question_type[typeKey];
                });
                sortedQuestionColumns.forEach(qKey => {
                    const header = `F${String(markingScheme[qKey].relativeQNoInSubject).padStart(3, '0')}`;
                    row[header] = rowData[qKey];
                });
                return row;
            }));
        }

        function renderResponseAnalysisTable() {
            if (studentData.length === 0 || currentExamType === 'subjective') {
                responseAnalysisDiv.innerHTML = '';
                return;
            }

            responseAnalysisDiv.innerHTML = `
                <div class="results-tab-header">
                    <h3>Student Response Analysis</h3>
                    <button id="downloadResponseBtn" class="btn-download" style="font-size: 14px; padding: 8px 16px;">Download Excel</button>
                </div>
                <div class="table-wrapper">
                    <table class="results-table" id="responseTable"></table>
                </div>
                <div id="responsePagination"></div>
            `;
            
            renderTableWithPagination('responseTable', 'responsePagination', studentData, 10, (student) => {
                const finalQuestionKeys = Object.keys(markingScheme).sort((a, b) => parseInt(a.slice(1)) - parseInt(b.slice(1)));
                let rowHtml = `<td class="sticky-col">${student.frmid}</td>`;

                finalQuestionKeys.forEach(qKey => {
                    const questionInfo = markingScheme[qKey];
                    const studentResult = calculatedResults.find(res => res.frmid === student.frmid);
                    let cellClass = '';
                    let cellContent = student[qKey] || '';

                    if (questionInfo && String(questionInfo.questionType || '').toLowerCase() === 'mm') {
                        let mmResult;
                        if (currentExamType === 'jee' && formatSelector.value.includes('excel')) {
                            mmResult = compareMMAnswersExcel(questionInfo.correctAnswer, student[qKey]);
                        } else {
                            mmResult = compareMMAnswersDat(questionInfo.correctAnswer, student[qKey]);
                        }
                        cellContent = generateGrid(mmResult.studentBlocks, mmResult.rowStatus, false); // isPdf is false for web view
                    }
                    
                    if (studentResult) {
                        if (studentResult.question_is_bonus[qKey]) {
                            cellClass = 'bonus-answer-cell';
                            cellContent = `<span class="bonus-marker">**</span>${cellContent}`;
                        } else if (studentResult.question_correctness[qKey]) {
                            cellClass = 'correct-answer-cell';
                        } else if (studentResult.question_partial_correctness[qKey]) {
                            cellClass = 'partially-correct-cell';
                        } else if (student[qKey] && String(student[qKey] || '').toLowerCase() !== 'x') {
                            cellClass = 'wrong-answer-cell';
                        }
                    }
                    rowHtml += `<td class="${cellClass}">${cellContent}</td>`;
                });
                return rowHtml;
            }, () => {
                const finalQuestionKeys = Object.keys(markingScheme).sort((a, b) => parseInt(a.slice(1)) - parseInt(b.slice(1)));
                const headers = ['FRMID'];
                finalQuestionKeys.forEach(qKey => {
                    const questionInfo = markingScheme[qKey];
                    const type = String(questionInfo.questionType || '').toUpperCase();
                    const subject = questionInfo.subject ? (SUBJECT_SHORT_NAMES[questionInfo.subject] || questionInfo.subject) : 'N/A';
                    const originalQNo = questionInfo.relativeQNoInSubject ? questionInfo.relativeQNoInSubject : parseInt(qKey.slice(1));
                    let headerText = `Q${originalQNo} (${subject} - ${type})`;
                    if (type.toLowerCase() === 'mm') {
                        headerText += `<br/>Correct:<br/>${generateGrid(compareMMAnswersDat(questionInfo.correctAnswer, '').correctBlocks, Array(4).fill("correct"), false)}`; // isPdf is false for web view
                    } else {
                        headerText += ` [${questionInfo.correctAnswer}]`;
                    }
                    headers.push(headerText);
                });
                return headers;
            });

            document.getElementById('downloadResponseBtn').addEventListener('click', () => downloadDataAsExcel(studentData, 'Response_Analysis.xlsx', (student) => {
                const row = { 'FRMID': student.frmid };
                const finalQuestionKeys = Object.keys(markingScheme).sort((a, b) => parseInt(a.slice(1)) - parseInt(b.slice(1)));
                finalQuestionKeys.forEach(qKey => {
                    const questionInfo = markingScheme[qKey];
                    const header = `Q${questionInfo.relativeQNoInSubject}`;
                    row[header] = student[qKey];
                });
                return row;
            }));
        }

        function renderTableWithPagination(tableId, paginationId, data, rowsPerPage, renderRowCallback, getHeadersCallback, headerGroups = []) {
            const tableContainer = document.getElementById(tableId)?.parentElement;
            const paginationContainer = document.getElementById(paginationId);
            if (!tableContainer || !paginationContainer) return;

            tableContainer.innerHTML = `<table class="summary-table" id="${tableId}"></table>`;
            const table = document.getElementById(tableId);
            paginationContainer.innerHTML = '';

            let currentPage = 1;
            
            function displayPage(page) {
                currentPage = page;
                table.innerHTML = ''; // Clear previous table content
                const thead = table.createTHead();
                const tbody = table.createTBody();
                
                // Handle grouped headers
                if (headerGroups.length > 0) {
                    const groupRow = thead.insertRow();
                    headerGroups.forEach(group => {
                        const th = document.createElement('th');
                        th.textContent = group.name;
                        th.colSpan = group.span;
                        groupRow.appendChild(th);
                    });
                }

                const headerRow = thead.insertRow();
                const headers = getHeadersCallback();
                headers.forEach((headerText, index) => {
                    const th = document.createElement('th');
                    th.innerHTML = headerText;
                    if (index < 4) th.classList.add('sticky-col');
                    headerRow.appendChild(th);
                });
                
                const start = (page - 1) * rowsPerPage;
                const end = start + rowsPerPage;
                const paginatedItems = data.slice(start, end);

                paginatedItems.forEach((item, index) => {
                    const tr = tbody.insertRow();
                    tr.innerHTML = renderRowCallback(item, start + index);
                });
                setupPaginationControls(data.length, rowsPerPage, page, Math.ceil(data.length / rowsPerPage), displayPage);
            }

            function setupPaginationControls(totalItems, itemsPerPage, currentPage, totalPages, onPageChange) {
                paginationContainer.innerHTML = '';
                
                let paginationHtml = `
                    <div class="pagination-controls">
                        <div class="pagination-info">${totalItems} results</div>
                        <div class="pagination-nav">
                            <label for="${paginationId}-rowsPerPage">Results per page:</label>
                            <select id="${paginationId}-rowsPerPage" style="width: auto; padding: 8px; border-radius: 6px;">
                                <option value="10" ${itemsPerPage === 10 ? 'selected' : ''}>10</option>
                                <option value="25" ${itemsPerPage === 25 ? 'selected' : ''}>25</option>
                                <option value="50" ${itemsPerPage === 50 ? 'selected' : ''}>50</option>
                                <option value="99999" ${itemsPerPage > 50 ? 'selected' : ''}>All</option>
                            </select>
                            <button class="pagination-btn" id="${paginationId}-firstPageBtn" ${currentPage === 1 || totalPages <= 1 ? 'disabled' : ''}>&laquo;</button>
                            <button class="pagination-btn" id="${paginationId}-prevPageBtn" ${currentPage === 1 || totalPages <= 1 ? 'disabled' : ''}>&lsaquo;</button>
                `;

                if (totalPages > 1) {
                    const maxPagesToShow = 10;
                    let startPage, endPage;

                    if (totalPages <= maxPagesToShow) {
                        startPage = 1;
                        endPage = totalPages;
                    } else {
                        const maxPagesBeforeCurrent = Math.floor(maxPagesToShow / 2);
                        const maxPagesAfterCurrent = Math.ceil(maxPagesToShow / 2) - 1;
                        if (currentPage <= maxPagesBeforeCurrent) {
                            startPage = 1;
                            endPage = maxPagesToShow;
                        } else if (currentPage + maxPagesAfterCurrent >= totalPages) {
                            startPage = totalPages - maxPagesToShow + 1;
                            endPage = totalPages;
                        } else {
                            startPage = currentPage - maxPagesBeforeCurrent;
                            endPage = currentPage + maxPagesAfterCurrent;
                        }
                    }

                    for (let i = startPage; i <= endPage; i++) {
                        paginationHtml += `<button class="pagination-btn ${i === currentPage ? 'active' : ''}" data-page="${i}">${i}</button>`;
                    }
                }
                
                paginationHtml += `
                            <button class="pagination-btn" id="${paginationId}-nextPageBtn" ${currentPage === totalPages || totalPages <= 1 ? 'disabled' : ''}>&rsaquo;</button>
                            <button class="pagination-btn" id="${paginationId}-lastPageBtn" ${currentPage === totalPages || totalPages <= 1 ? 'disabled' : ''}>&raquo;</button>
                        </div>
                    </div>
                `;
                paginationContainer.innerHTML = paginationHtml;

                paginationContainer.querySelector(`#${paginationId}-rowsPerPage`).addEventListener('change', (e) => {
                    const newRowsPerPage = parseInt(e.target.value);
                    renderTableWithPagination(tableId, paginationId, data, newRowsPerPage, renderRowCallback, getHeadersCallback, headerGroups);
                });

                if (totalPages > 1) {
                    paginationContainer.querySelector(`#${paginationId}-firstPageBtn`).addEventListener('click', () => onPageChange(1));
                    paginationContainer.querySelector(`#${paginationId}-prevPageBtn`).addEventListener('click', () => onPageChange(currentPage - 1));
                    paginationContainer.querySelector(`#${paginationId}-nextPageBtn`).addEventListener('click', () => onPageChange(currentPage + 1));
                    paginationContainer.querySelector(`#${paginationId}-lastPageBtn`).addEventListener('click', () => onPageChange(totalPages));
                    paginationContainer.querySelectorAll('.pagination-btn[data-page]').forEach(btn => {
                        btn.addEventListener('click', (e) => onPageChange(parseInt(e.target.dataset.page)));
                    });
                }
            }
            
            displayPage(1);
        }

        /** PDF and Excel Generation **/

        function downloadDataAsExcel(data, fileName, formatRowCallback) {
            if (!data || data.length === 0) {
                showModal('Error', 'No data available to download.', 'error');
                return;
            }
            try {
                const formattedData = data.map(formatRowCallback);
                const worksheet = XLSX.utils.json_to_sheet(formattedData);
                const workbook = XLSX.utils.book_new();
                XLSX.utils.book_append_sheet(workbook, worksheet, 'Data');
                XLSX.writeFile(workbook, `${getFormattedTestFileName()}_${fileName}`);
                showModal('Success', 'Excel file has been downloaded.', 'success', 3000);
            } catch (error) {
                showModal('Error', `Failed to generate Excel file: ${error.message}`, 'error');
            }
        }

        function getFormattedTestFileName() {
            const testName = testNameInput.value.trim().replace(/[^a-zA-Z0-9]/g, '_');
            const testDate = testDateInput.value;
            return `${testName}_${testDate}`;
        }

        function exportStyledExcel(fileName, sheetName, title, subtitle, headers, dataRows, headerGroups = []) {
            const titleStyle = { font: { name: 'Calibri', sz: 18, bold: true, color: { rgb: "FFFFFFFF" } }, fill: { fgColor: { rgb: "FF003366" } }, alignment: { horizontal: "center", vertical: "center" } };
            const subtitleStyle = { font: { name: 'Calibri', sz: 14, bold: true, color: { rgb: "FFFFFFFF" } }, fill: { fgColor: { rgb: "FF003366" } }, alignment: { horizontal: "center", vertical: "center" } };
            const groupHeaderStyle = { font: { sz: 12, bold: true, color: { rgb: "FFFFFFFF" } }, fill: { fgColor: { rgb: "FF003366" } }, alignment: { horizontal: "center" }, border: { top: { style: "thin" }, bottom: { style: "thin" }, left: { style: "thin" }, right: { style: "thin" } } };
            const subHeaderStyle = { font: { bold: true, color: { rgb: "FFFFFFFF" } }, fill: { fgColor: { rgb: "FF003366" } }, alignment: { horizontal: "center", vertical: "center" }, border: { top: { style: "thin" }, bottom: { style: "thin" }, left: { style: "thin" }, right: { style: "thin" } } };
            const cellStyle = { border: { top: { style: "thin" }, bottom: { style: "thin" }, left: { style: "thin" }, right: { style: "thin" } } };

            const worksheetData = [ [title], [subtitle] ];
            if (headerGroups.length > 0) {
                const groupNames = [];
                headerGroups.forEach(g => {
                    groupNames.push(g.name);
                    for(let i = 1; i < g.span; i++) groupNames.push("");
                });
                 worksheetData.push(groupNames);
            }
            worksheetData.push(headers);
            dataRows.forEach(row => worksheetData.push(row));

            const ws = XLSX.utils.aoa_to_sheet(worksheetData);
            
            const colWidths = headers.map((_, i) => ({ wch: 0 }));
            worksheetData.forEach(row => {
                row.forEach((cell, i) => {
                    const len = cell ? String(cell).length : 0;
                    if (colWidths[i].wch < len) {
                        colWidths[i].wch = len;
                    }
                });
            });
            colWidths.forEach(col => { col.wch = Math.max(10, col.wch + 2); });
            ws['!cols'] = colWidths;
            
            const headerRowCount = (headerGroups.length > 0) ? 3 : 2;
            const totalCols = headers.length;

            ws['!merges'] = [
                { s: { r: 0, c: 0 }, e: { r: 0, c: totalCols - 1 } },
                { s: { r: 1, c: 0 }, e: { r: 1, c: totalCols - 1 } }
            ];

            if (headerGroups.length > 0) {
                let colCounter = 0;
                headerGroups.forEach(group => {
                    if (group.span > 1) {
                        ws['!merges'].push({ s: { r: 2, c: colCounter }, e: { r: 2, c: colCounter + group.span - 1 } });
                    }
                    colCounter += group.span;
                });
            }

            const range = XLSX.utils.decode_range(ws['!ref']);
            for (let R = 0; R <= range.e.r; ++R) {
                for (let C = 0; C <= range.e.c; ++C) {
                    const cell_ref = XLSX.utils.encode_cell({ c: C, r: R });
                    if (!ws[cell_ref]) continue;

                    if (R === 0) ws[cell_ref].s = titleStyle;
                    else if (R === 1) ws[cell_ref].s = subtitleStyle;
                    else if (R === 2 && headerGroups.length > 0) ws[cell_ref].s = groupHeaderStyle;
                    else if (R === headerRowCount) ws[cell_ref].s = subHeaderStyle;
                    else ws[cell_ref].s = cellStyle;
                }
            }
            
            const wb = XLSX.utils.book_new();
            XLSX.utils.book_append_sheet(wb, ws, sheetName);
            XLSX.writeFile(wb, fileName);
        }

        function downloadObjectiveResults(includeRank, type) {
            if (type === 'pdf') {
                const dataToExportForPdf = summaryResults.map(row => {
                    const exportRow = [row['Sno.'], row['Fno.'], row['Student Name'], row['Batch'], row.correct_count, row.incorrect_count, row.left_count];
                    uniqueSubjects.forEach(sub => exportRow.push(formatNumberToTwoDecimals(row[`marks_${sub.toLowerCase()}`])));
                    if (uniqueSubjects.length > 1) exportRow.push(formatNumberToTwoDecimals(row.total_marks));
                    exportRow.push(row.percentage.toFixed(2), row.percentile);
                    if (includeRank) exportRow.push(row.rank);
                    return exportRow;
                });
                generateObjectiveSummaryPdf(dataToExportForPdf, includeRank);
                return;
            }

            const testName = testNameInput.value.trim();
            const testDate = testDateInput.value ? formatDateToDdMmmYyyy(testDateInput.value) : '';
            const title = "Test Results";
            const subtitle = `${testName} | ${testDate}`;

            const orderedSubjects = [...uniqueSubjects].sort((a,b) => (PREDEFINED_SUBJECT_ORDER.indexOf(a) || 99) - (PREDEFINED_SUBJECT_ORDER.indexOf(b) || 99));
            
            const headers = ['Sno.', 'Fno.', 'Student Name', 'Batch', 'Correct', 'Wrong', 'Left', ...orderedSubjects.map(s => `${SUBJECT_SHORT_NAMES[s] || s} (${formatNumberToTwoDecimals(maxMarksBySubject[s] || 0)})`)];
            
            if (uniqueSubjects.length > 1) {
                headers.push(`Total (${formatNumberToTwoDecimals(overallMaxMarks)})`);
            }
            headers.push('%age', '%tile');
            if (includeRank) {
                headers.push('Rank');
            }
            
            let overallColSpan = 2; // for %age and %tile
            if (uniqueSubjects.length > 1) overallColSpan++; // for Total
            if (includeRank) overallColSpan++;

            const headerGroups = [
                { name: 'Student Info', span: 4 },
                { name: 'Attempted', span: 3 },
                { name: 'Subject Scores', span: orderedSubjects.length },
                { name: 'Overall Score & Rank', span: overallColSpan }
            ].filter(g => g.span > 0);

            const dataRows = summaryResults.map(row => {
                const dataRow = [row['Sno.'], row['Fno.'], row['Student Name'], row['Batch'], row.correct_count, row.incorrect_count, row.left_count];
                orderedSubjects.forEach(sub => {
                    dataRow.push(parseFloat(formatNumberToTwoDecimals(row[`marks_${sub.toLowerCase()}`])));
                });
                if (uniqueSubjects.length > 1) {
                    dataRow.push(parseFloat(formatNumberToTwoDecimals(row.total_marks)));
                }
                dataRow.push(parseFloat(row.percentage));
                dataRow.push(parseFloat(row.percentile));
                if (includeRank) {
                    dataRow.push(row.rank);
                }
                return dataRow;
            });

            const baseFileName = getFormattedTestFileName();
            const finalFileName = `${baseFileName}_Summary_Results_${includeRank ? 'WithRank' : 'WithoutRank'}.xlsx`;
            
            exportStyledExcel(finalFileName, 'Summary Results', title, subtitle, headers, dataRows, headerGroups);
        }

        async function generateObjectiveSummaryPdf(data, includeRank) {
            if (data.length === 0) {
                showModal('Error', 'No data available to generate summary PDF.', 'error');
                return;
            }

            showModal('Info', 'Generating Summary PDF...', 'info', 0);
            toggleSpinner(true);

            const doc = new jsPDF('p', 'mm', 'a4');
            
            addStatisticsToPdf(doc);

            const orderedSubjects = [...uniqueSubjects].sort((a, b) => (PREDEFINED_SUBJECT_ORDER.indexOf(a) || 99) - (PREDEFINED_SUBJECT_ORDER.indexOf(b) || 99));

            const showTotalColumn = uniqueSubjects.length > 1;
            let overallColSpan = 2; // for %age and %tile
            if (includeRank) overallColSpan++;
            if (showTotalColumn) overallColSpan++;

            const mainHeaders = [
                { content: 'Student Info', colSpan: 4, styles: { halign: 'center' } },
                { content: 'Attempted', colSpan: 3, styles: { halign: 'center' } },
                { content: 'Subject', colSpan: orderedSubjects.length, styles: { halign: 'center' } },
                { content: 'Overall Score & Rank', colSpan: overallColSpan, styles: { halign: 'center' } }
            ];
            
            // REPLACE WITH THIS CODE
            const subHeaders = ['Sno.', 'Fno.', 'Student Name', 'Batch', 'Correct', 'Wrong', 'Left', ...orderedSubjects.map(s => `${SUBJECT_SHORT_NAMES[s] || s} (${formatNumberToTwoDecimals(maxMarksBySubject[s])})`)];
            if (showTotalColumn) subHeaders.push(`Total (${formatNumberToTwoDecimals(overallMaxMarks)})`);
            subHeaders.push('%age', '%tile');
            if (includeRank) subHeaders.push('Rank');

            const head = [mainHeaders, subHeaders];
            const bodyData = data;

            try {
                doc.autoTable({
                    head: head,
                    body: bodyData,
                    startY: 40,
                    margin: { left: 5, right: 5 },
                    theme: 'grid',
                    headStyles: { fillColor: [217, 217, 217], textColor: [0, 0, 0], fontStyle: 'bold', fontSize: 8, halign: 'center' },
                    styles: { fontSize: 8, halign: 'center', textColor: [0, 0, 0], lineColor: [0, 0, 0], lineWidth: 0.1 },
                    columnStyles: { 2: { halign: 'left' } },
                    didDrawCell: function(data) {
                        if (data.section === 'body') {
                            if (data.column.index === 4) { // Correct
                                doc.setTextColor(16, 163, 74); // success-color
                            } else if (data.column.index === 5) { // Wrong
                                doc.setTextColor(220, 38, 38); // error-color
                            }
                        }
                    },
                    willDrawPage: function(data) {
                        doc.setTextColor(0, 0, 0); // Reset color for headers, footers etc.
                    }
                });

                doc.save(`${getFormattedTestFileName()}_Summary_Report_${includeRank ? 'WithRank' : 'WithoutRank'}.pdf`);
                showModal('Success', 'PDF successfully generated!', 'success', 3000);

            } catch (error) {
                console.error('Failed to generate summary PDF:', error);
                showModal('Error', `Failed to generate summary PDF: ${error.message}`, 'error');
            } finally {
                toggleSpinner(false);
            }
        }
        
        async function generateStudentPdfs() {
            if (studentData.length === 0) {
                showModal('Error', 'No student response data available to generate individual PDFs.', 'error');
                return;
            }

            const totalStudents = studentData.length;
            showModal('Info', `Starting PDF Generation for ${totalStudents} students...`, 'info', 0);
            toggleSpinner(true);

            const pdf = new jsPDF('p', 'mm', 'a4');

            const testName = testNameInput.value.trim();
            const testDate = testDateInput.value ? formatDateToDdMmmYyyy(testDateInput.value) : '';

            const subjectCount = uniqueSubjects.length;
            const useCompactColumns = subjectCount > 3 || questionColumns.length > 70;

            for (let i = 0; i < totalStudents; i++) {
                showModal('Info', `Generating PDF ${i + 1} of ${totalStudents}... Please wait.`, 'info', 0);

                const student = studentData[i];
                const studentResult = calculatedResults.find(res => res.frmid === student.frmid);
                const studentDetail = studentDetailsMap.get(String(student.frmid || '').trim().toLowerCase()) || {};
                const studentName = studentDetail.studentName || student['student name'] || 'N/A';
                const batch = studentDetail.batch || student['batch'] || 'N/A';

                const pdfContentDiv = document.createElement('div');
                pdfContentDiv.className = 'pdf-content';
                pdfContentDiv.style.position = 'absolute';
                pdfContentDiv.style.left = '-9999px';
                pdfContentDiv.style.width = '210mm';
                document.body.appendChild(pdfContentDiv);

                
// REPLACE WITH THIS CODE
// REPLACE WITH THIS NEW SECTION
let studentInfoHtml = '';
if (studentResult) {
    studentInfoHtml = `
        <div class="student-info" style="display: flex; justify-content: space-between; align-items: stretch; padding: 10px 5px;">
            <div style="flex-basis: 55%; padding-right: 10px; display: flex; flex-direction: column; justify-content: center;">
                <p style="font-size: 13px; margin: 3px 0; font-weight: 600;"><strong>F. No.:</strong> ${student.frmid}</p>
                <p style="font-size: 13px; margin: 3px 0; font-weight: 600;"><strong>Student Name:</strong> ${studentName}</p>
                <p style="font-size: 13px; margin: 3px 0; font-weight: 600;"><strong>Batch:</strong> ${batch}</p>
            </div>

            <div style="border-left: 1px solid #ccc;"></div>

            <div style="flex-basis: 45%; display: flex; flex-direction: column; justify-content: center; align-items: center; padding-left: 10px;">
                <div style="text-align: center; margin-bottom: 8px;">
                    <span style="font-weight: 800; font-size: 32px; color: #000; display: block; line-height: 1;">${formatNumberToTwoDecimals(studentResult.total)}</span>
                    <span style="font-size: 9px; text-transform: uppercase; color: #555; font-weight: 600; display: block; letter-spacing: 0.5px;">Your Score</span>
                </div>
                <div style="font-size: 11px; font-weight: 600; color: #333; white-space: nowrap;">
                    <span>Correct: <strong style="color: #16a34a;">${studentResult.correct_count}</strong></span>
                    <span style="margin: 0 8px;">|</span>
                    <span>Incorrect: <strong style="color: #dc2626;">${studentResult.incorrect_count}</strong></span>
                    <span style="margin: 0 8px;">|</span>
                    <span>Left: <strong>${studentResult.left_count}</strong></span>
                </div>
            </div>
        </div>
    `;
} else {
    // Fallback for cases where there are no results (optional)
    studentInfoHtml = `
        <div class="student-info">
             <p><strong>F. No.:</strong> ${student.frmid}</p>
             <p><strong>Student Name:</strong> ${studentName}</p>
             <p><strong>Batch:</strong> ${batch}</p>
        </div>
    `;
}


let contentHTML = `
    <div class="pdf-header">
        <h1>Response Sheet</h1>
        <p class="test-info-line">${testName} | ${testDate}</p>
    </div>
    ${studentInfoHtml}
    <div class="subjects-container">
`;                


                const questionsBySubject = {};
                uniqueSubjects.forEach(sub => questionsBySubject[sub] = []);
                
                const finalQuestionKeys = Object.keys(markingScheme).sort((a, b) => parseInt(a.slice(1)) - parseInt(b.slice(1)));

                finalQuestionKeys.forEach(qKey => {
                    const questionInfo = markingScheme[qKey];
                    if (!questionInfo) return;
                    
                    if(questionsBySubject[questionInfo.subject]) {
                        questionsBySubject[questionInfo.subject].push({
                            qNo: questionInfo.relativeQNoInSubject || parseInt(qKey.slice(1)), 
                            studentResponse: student[qKey] || 'N.A.', 
                            qKey: qKey, 
                            type: String(questionInfo.questionType || '').toUpperCase(), 
                            correctAnswer: questionInfo.correctAnswer || ''
                        });
                    }
                });
                
                const minQuestionPerSubject = {};
                for (const qKey in markingScheme) {
                    const scheme = markingScheme[qKey];
                    const qNum = parseInt(qKey.substring(1));
                    if (!minQuestionPerSubject[scheme.subject] || qNum < minQuestionPerSubject[scheme.subject]) {
                        minQuestionPerSubject[scheme.subject] = qNum;
                    }
                }
                const orderedSubjects = [...uniqueSubjects].sort((a, b) => (minQuestionPerSubject[a] || 999) - (minQuestionPerSubject[b] || 999));

                
                const pdfColumns = [];
                const chunkSize = 45;

                orderedSubjects.forEach(subject => {
                    const questionsInSubject = questionsBySubject[subject].sort((a, b) => a.qNo - b.qNo);
                    if (questionsInSubject.length === 0) return;

                    if (questionsInSubject.length <= chunkSize) {
                        pdfColumns.push({ subjectName: subject, questions: questionsInSubject });
                    } else {
                        for (let i = 0; i < questionsInSubject.length; i += chunkSize) {
                            const chunk = questionsInSubject.slice(i, i + chunkSize);
                            pdfColumns.push({ subjectName: subject, questions: chunk });
                        }
                    }
                });

                pdfColumns.forEach(columnData => {
                    contentHTML += `<div class="pdf-subject-column"><h3>${columnData.subjectName}</h3>`;
                    
                    const tableHeader = useCompactColumns
                        ? `<thead><tr><th>Q.No.</th><th>Response</th></tr></thead>`
                        : `<thead><tr><th>Q.No.</th><th>Response</th><th>Correct Answer</th><th>Status</th></tr></thead>`;
                    
                    contentHTML += `<table class="pdf-response-table">${tableHeader}<tbody>`;
                    
                    columnData.questions.forEach(questionInSubject => {
                        if (!questionInSubject) return;
                        
                        let correctAnswerForDisplay = questionInSubject.correctAnswer;
                        let studentResponseForDisplay = questionInSubject.studentResponse;

                        const questionInfoFromScheme = markingScheme[questionInSubject.qKey];
                        if (!questionInfoFromScheme) return;

                        // REPLACE WITH THIS
if (['mm', 'cm'].includes(String(questionInfoFromScheme.questionType || '').toLowerCase())) {
    // For PDF, do not render grid, show raw text.
    // The default values assigned above will be used automatically, so this block is left intentionally simple.
} else if (['id', 'im', 'sint', 'is'].includes(String(questionInfoFromScheme.questionType || '').toLowerCase())) {
                            studentResponseForDisplay = questionInSubject.studentResponse;
                            correctAnswerForDisplay = questionInSubject.correctAnswer;
                        } else if (['sc', 'cs', 'mc', 'mp'].includes(String(questionInfoFromScheme.questionType || '').toLowerCase())) {
                            correctAnswerForDisplay = correctAnswerForDisplay.toUpperCase().split('').join(',');
                            studentResponseForDisplay = studentResponseForDisplay.toUpperCase().split('').join(',');
                        }

                        if (useCompactColumns) {
                            contentHTML += `<tr><td>${questionInSubject.qNo}</td><td>${studentResponseForDisplay}</td></tr>`;
                        } else {
                            const studentResult = calculatedResults.find(res => res.frmid === student.frmid);
                            let statusText = 'N.A.';
                            let statusClass = ''; 

                            if (studentResult && studentResult.question_correctness[questionInSubject.qKey] !== undefined) {
                                if (studentResult.question_is_bonus[questionInSubject.qKey]) {
                                    statusText = 'Bonus';
                                } else if (studentResult.question_correctness[questionInSubject.qKey]) {
                                    statusText = 'Correct';
                                } else if (studentResult.question_partial_correctness[questionInSubject.qKey]) {
                                    statusText = 'Partial';
                                } else if (questionInSubject.studentResponse.toLowerCase() !== 'x' && questionInSubject.studentResponse.toLowerCase() !== 'n.a.') {
                                    statusText = 'Wrong';
                                }
                            }
                            contentHTML += `<tr class="${statusClass}"><td>${questionInSubject.qNo}</td><td>${studentResponseForDisplay}</td><td>${correctAnswerForDisplay}</td><td>${statusText}</td></tr>`;
                        }
                    });
                    
                    contentHTML += `</tbody></table></div>`;
                });


                contentHTML += `</div>`;
                pdfContentDiv.innerHTML = contentHTML;
                
                const canvas = await html2canvas(pdfContentDiv, { scale: 1.5, logging: false });
                const imgData = canvas.toDataURL('image/jpeg', 0.75);

                if (i > 0) pdf.addPage();
                
                const pageHeight = pdf.internal.pageSize.getHeight();
                const pageWidth = pdf.internal.pageSize.getWidth();
                const margin = 5; 
                
                const imgProps = pdf.getImageProperties(imgData);
                
                let finalImgWidth = pageWidth - (margin * 2);
                let finalImgHeight = (imgProps.height * finalImgWidth) / imgProps.width;

                if (finalImgHeight > (pageHeight - (margin * 2))) {
                    finalImgHeight = pageHeight - (margin * 2);
                    finalImgWidth = (imgProps.width * finalImgHeight) / imgProps.height;
                }

                const xOffset = (pageWidth - finalImgWidth) / 2;

                pdf.addImage(imgData, 'JPEG', xOffset, margin, finalImgWidth, finalImgHeight);

                document.body.removeChild(pdfContentDiv);
            }
            pdf.save(`${getFormattedTestFileName()}_All_Student_Response_Sheets.pdf`);
            
            toggleSpinner(false);
            showModal('Success', 'PDF generation complete!', 'success', 3000);
        }
        
        function downloadSubjectiveExcel() {
             const testName = testNameInput.value.trim();
            const testDate = testDateInput.value ? formatDateToDdMmmYyyy(testDateInput.value) : '';
            const title = "Subjective Test Results";
            const subtitle = `${testName} | ${testDate}`;

            const headers = ['Sno.', 'Fno.', 'Student Name', 'Batch', ...uniqueSubjects.map(s => `${s.toUpperCase()} (${formatNumberToTwoDecimals(maxMarksBySubject[s])})`), `Total Marks (${formatNumberToTwoDecimals(overallMaxMarks)})`, '%age', 'Rank'];
            
            const headerGroups = [
                { name: 'Student Info', span: 4 },
                { name: 'Subject Scores', span: uniqueSubjects.length },
                { name: 'Overall Score & Rank', span: 3 }
            ].filter(g => g.span > 0);

            const dataRows = calculatedResults.map((res, index) => {
                const row = [index + 1, res.frmid, res.studentName, res.batch];
                uniqueSubjects.forEach(sub => row.push(res.marks_by_subject[sub]));
                row.push(res.total_marks, parseFloat(res.percentage.toFixed(2)), res.rank);
                return row;
            });
            
            const finalFileName = `${getFormattedTestFileName()}_Subjective_Results.xlsx`;
            exportStyledExcel(finalFileName, 'Subjective Summary', title, subtitle, headers, dataRows, headerGroups);
        }

        function downloadSubjectivePdf() {
            const doc = new jsPDF('p', 'mm', 'a4');
            const testName = testNameInput.value.trim();
            const testDate = testDateInput.value ? formatDateToDdMmmYyyy(testDateInput.value) : '';
            
            addStatisticsToPdf(doc);

            // REPLACE WITH THIS CODE
            // REPLACE WITH THIS CODE
            const headers = [['Sno.', 'Fno.', 'Student Name', 'Batch', ...uniqueSubjects.map(s => `${s.toUpperCase()} (${formatNumberToTwoDecimals(maxMarksBySubject[s])})`), `Total (${formatNumberToTwoDecimals(overallMaxMarks)})`, '%age', 'Rank']];
            const data = calculatedResults.map((res, index) => [
                index + 1,
                res.frmid,
                res.studentName,
                res.batch,
                ...uniqueSubjects.map(sub => formatNumberToTwoDecimals(res.marks_by_subject[sub])),
                formatNumberToTwoDecimals(res.total_marks),
                res.percentage.toFixed(2),
                res.rank
            ]);
            
            doc.autoTable({
                head: headers,
                body: data,
                startY: 40, // Adjust startY for stats
                margin: { left: 5, right: 5 },
                theme: 'grid',
                headStyles: { fillColor: [217, 217, 217], textColor: [0, 0, 0], fontStyle: 'bold', fontSize: 9, halign: 'center' },
                styles: { fontSize: 9, halign: 'center', textColor: [0, 0, 0], lineColor: [0, 0, 0], lineWidth: 0.1 },
            });
            doc.save(`${getFormattedTestFileName()}_Subjective_Report.pdf`);
            showModal('Success', 'PDF successfully generated!', 'success', 3000);
        }

        function formatDateForPdf(dateStr) {
            const [year, month, day] = dateStr.split('-');
            const date = new Date(year, month - 1, day);
            return date.toLocaleDateString('en-US', { day: '2-digit', month: 'long', year: 'numeric' }).toUpperCase();
        }

        
        /** Initial Setup & Event Listeners **/
        function resetGlobalState(resetInputs = true) {
            studentData = []; markingScheme = {}; studentDetailsMap.clear();
            calculatedResults = []; summaryResults = []; maxMarksBySubject = {};
            overallMaxMarks = 0; uniqueSubjects = []; uniqueQuestionTypes = [];
            questionColumns = []; validationMessages = []; rankingCriteria = [];
            overallStats = {}; // Reset stats
            resultsContainer.style.display = 'none';
            summaryResultsDiv.innerHTML = '';
            detailedResultsDiv.innerHTML = '';
            responseAnalysisDiv.innerHTML = '';
            
            if (resetInputs) {
                [testNameInput, testDateInput].forEach(input => input.value = '');
                [file1Input, file2Input, file3Input, subjectiveFile, subjectiveDetailsFile].forEach(input => {
                    input.value = '';
                    const nameDisplay = document.getElementById(input.id + 'Name');
                    if (nameDisplay) {
                       nameDisplay.textContent = 'No file chosen';
                    }
                    const label = document.querySelector(`label[for="${input.id}"]`);
                    if (label) {
                        label.classList.remove('uploaded');
                        const uploadBlock = label.closest('.upload-block');
                        if (uploadBlock) {
                            uploadBlock.classList.remove('uploaded-file');
                        }
                    }
                });
            }
        }

        function clearObjectiveSubjectiveFields() {
            document.getElementById('testName').value = '';
            document.getElementById('testDate').value = '';
            document.getElementById('file1').value = '';
            document.getElementById('file2').value = '';
            document.getElementById('file3').value = '';
            document.getElementById('subjectiveFile').value = '';
            document.getElementById('subjectiveDetailsFile').value = '';

            document.getElementById('file1Name').textContent = 'No file chosen';
            document.getElementById('file2Name').textContent = 'No file chosen';
            document.getElementById('file3Name').textContent = 'No file chosen';
            document.getElementById('subjectiveFileName').textContent = 'No file chosen';
            document.getElementById('subjectiveDetailsFileName').textContent = 'No file chosen';

            ['file1', 'file2', 'file3', 'subjectiveFile', 'subjectiveDetailsFile'].forEach(id => {
                const label = document.querySelector(`label[for="${id}"]`);
                if (label) {
                    label.classList.remove('uploaded');
                    label.closest('.upload-block').classList.remove('uploaded-file');
                }
            });

            resultsContainer.style.display = 'none';
            document.getElementById('summaryResults').innerHTML = '';
            document.getElementById('detailedResults').innerHTML = '';
            document.getElementById('responseAnalysis').innerHTML = '';
            
            checkInputsAndEnableProcessButton();
            resetGlobalState(false);
        }

        function clearMergerFields(tabNum) {
            if (tabNum === 1) {
                document.getElementById('testNameInput1').value = '';
                document.getElementById('testDateInput1').value = '';
                document.getElementById('file1-merger').value = '';
                document.getElementById('file2-merger').value = '';
                document.getElementById('file1Name-merger').textContent = 'No file chosen';
                document.getElementById('file2Name-merger').textContent = 'No file chosen';
                document.getElementById('mergeBtn').disabled = true;
                document.getElementById('mergerResultsSection').style.display = 'none';
                mergerApp.file1Data = null;
                mergerApp.file2Data = null;
            } else if (tabNum === 2) {
                document.getElementById('testNameInput2').value = '';
                document.getElementById('testDateInput2').value = '';
                document.getElementById('file3-merger').value = '';
                document.getElementById('file4-merger').value = '';
                document.getElementById('file3Name-merger').textContent = 'No file chosen';
                document.getElementById('file4Name-merger').textContent = 'No file chosen';
                document.getElementById('mergeObjObjBtn').disabled = true;
                document.getElementById('mergerObjObjResultsSection').style.display = 'none';
                mergerApp.file3Data = null;
                mergerApp.file4Data = null;
            }
        }

        function updateUIForExamType(examType) {
            currentExamType = examType;
            
            primaryTabs.forEach(tab => tab.classList.remove('active'));
            
            if (examType === 'objective') {
                objectiveTabBtn.classList.add('active');
                objectiveSubjectiveApp.style.display = 'block';
                dataMergerApp.style.display = 'none';
                objectiveUploadSection.style.display = 'block';
                subjectiveUploadSection.style.display = 'none';
                updateResponseFileFormatsText(formatSelector.value);
            } else if (examType === 'subjective') {
                subjectiveTabBtn.classList.add('active');
                objectiveSubjectiveApp.style.display = 'block';
                dataMergerApp.style.display = 'none';
                objectiveUploadSection.style.display = 'none';
                subjectiveUploadSection.style.display = 'block';
            } else if (examType === 'merger') {
                mergerTabBtn.classList.add('active');
                objectiveSubjectiveApp.style.display = 'none';
                dataMergerApp.style.display = 'block';
            }
            
            resetGlobalState(true);
            checkInputsAndEnableProcessButton();
        }

        function updateResponseFileFormatsText(selectedFormat) {
            const downloadResponseTemplateBtn = document.getElementById('downloadResponseTemplateBtn');
            if (selectedFormat === 'jee_dat_cbt') {
                responseFileFormatsSpan.innerHTML = 'Supported Format: <span class="description-highlight">(.dat)</span>';
                file1Input.accept = '.dat';
                downloadResponseTemplateBtn.style.display = 'none'; 
            } else if (selectedFormat === 'jee_excel') {
                responseFileFormatsSpan.innerHTML = 'Supported Formats: <span class="description-highlight">(.xls, .xlsx, .csv) with F001-F126 columns</span>';
                file1Input.accept = '.xls,.xlsx,.csv';
                downloadResponseTemplateBtn.style.display = 'inline-flex';
            } else if (selectedFormat === 'neet_other') {
                responseFileFormatsSpan.innerHTML = 'Supported Formats <span class="description-highlight">(.dat, .xls, .xlsx, .csv)</span>';
                file1Input.accept = '.dat,.xls,.xlsx,.csv';
                downloadResponseTemplateBtn.style.display = 'inline-flex';
            }
        }

        function checkInputsAndEnableProcessButton() {
            let allFilled = false;
            if (currentExamType === 'subjective') {
                allFilled = testNameInput.value.trim() && testDateInput.value && subjectiveFile.files.length > 0;
            } else {
                allFilled = testNameInput.value.trim() && testDateInput.value && file1Input.files.length > 0 && file2Input.files.length > 0;
            }
            processBtn.disabled = !allFilled;
        }
        
        // Event listeners
        [testNameInput, testDateInput].forEach(el => el.addEventListener('input', checkInputsAndEnableProcessButton));

        [file1Input, file2Input, file3Input, subjectiveFile, subjectiveDetailsFile].forEach((input) => {
            input.addEventListener('change', () => {
                const span = document.getElementById(input.id + 'Name');
                const label = document.querySelector(`label[for="${input.id}"]`);
                const uploadBlock = label.closest('.upload-block');
                
                if (span && label && uploadBlock) {
                    span.textContent = input.files[0] ? input.files[0].name : 'No file chosen';
                    label.classList.toggle('uploaded', input.files.length > 0);
                    uploadBlock.classList.toggle('uploaded-file', input.files.length > 0);
                }
                
                checkInputsAndEnableProcessButton();
            });
        });

        objectiveTabBtn.addEventListener('click', () => updateUIForExamType('objective'));
        subjectiveTabBtn.addEventListener('click', () => updateUIForExamType('subjective'));
        mergerTabBtn.addEventListener('click', () => updateUIForExamType('merger'));
        
        formatSelector.addEventListener('change', () => {
            updateResponseFileFormatsText(formatSelector.value);
            file1Input.value = '';
            document.getElementById('file1Name').textContent = 'No file chosen';
            document.querySelector(`label[for="file1"]`).classList.remove('uploaded');
            document.querySelector(`label[for="file1"]`).closest('.upload-block').classList.remove('uploaded-file');
            checkInputsAndEnableProcessButton();
        });

        processBtn.addEventListener('click', startProcessing);
        clearObjectiveSubjectiveBtn.addEventListener('click', clearObjectiveSubjectiveFields);

        saveRankCriteriaBtn.addEventListener('click', () => {
            const priorityInputs = [...subjectRankList.querySelectorAll('li')];
            const priorities = new Map();
            let hasError = false;
            let duplicatePriorities = false;

            const criteria = priorityInputs.map(item => {
                const subject = item.dataset.subject;
                const input = item.querySelector('input');
                const priority = parseInt(input.value, 10);

                if (isNaN(priority) || priority < 1 || priority > priorityInputs.length) hasError = true;
                if (priorities.has(priority)) duplicatePriorities = true;
                priorities.set(priority, subject);
                
                return { subject, priority };
            });

            if (hasError) {
                showModal('Error', 'Please enter a valid priority number between 1 and ' + priorityInputs.length + '.', 'error');
                return;
            }
            if (duplicatePriorities) {
                showModal('Error', 'Do not use duplicate priority numbers. Each subject must have a unique priority.', 'error');
                return;
            }

            criteria.sort((a, b) => a.priority - b.priority);
            rankingCriteria = criteria.map(item => item.subject);
            
            hideModal();
            if (rankingModal.dataset.mode === 'objective') performObjectiveCalculationsAndRender();
            else if (rankingModal.dataset.mode === 'subjective') performSubjectiveCalculationsAndRender();
        });

        document.addEventListener('click', (e) => {
            const excelDropdownEl = document.getElementById('excelDropdown');
            const pdfDropdownEl = document.getElementById('pdfDropdown');

            if (excelDropdownEl && !e.target.closest('#downloadSummaryExcelBtn')) excelDropdownEl.classList.remove('show');
            if (pdfDropdownEl && !e.target.closest('#downloadSummaryPdfBtn')) pdfDropdownEl.classList.remove('show');
        });
        
        function showRankingModal(subjects, mode) {
            subjectRankList.innerHTML = '';
            const sortedSubjects = [...subjects].sort((a,b) => (PREDEFINED_SUBJECT_ORDER.indexOf(a.toUpperCase()) || 99) - (PREDEFINED_SUBJECT_ORDER.indexOf(b.toUpperCase()) || 99));

            sortedSubjects.forEach((subject, index) => {
                const li = document.createElement('li');
                li.dataset.subject = subject;
                li.className = 'ranking-item';
                li.innerHTML = `<span>${subject.toUpperCase()}</span><input type="number" min="1" max="${sortedSubjects.length}" value="${index + 1}">`;
                subjectRankList.appendChild(li);
            });
            rankingModal.dataset.mode = mode;
            rankingModal.classList.add('show');
        }


        modalCloseBtn.addEventListener('click', hideModal);
        closeRankingModalBtn.addEventListener('click', () => { hideModal(); toggleSpinner(false); });
        errorModal.addEventListener('click', (e) => { if (e.target === errorModal) hideModal(); });
        rankingModal.addEventListener('click', (e) => { if (e.target === rankingModal) { hideModal(); toggleSpinner(false); }});


        // Template Downloads
        [downloadTemplateBtn, downloadResponseTemplateBtn, downloadDetailsTemplateBtn, downloadDetailsTemplateBtnSubjective].forEach(btn => {
            btn.addEventListener('click', () => {
                let templateData = "";
                let fileName = "";
                if (btn.id === 'downloadTemplateBtn') {
                    templateData = "Section,Que.No.,Subject,Ques Type,Correct Answer,Right Marks,Negative Marks,Bonus\n1,1,PHYSICS,SC,A,4,1,0";
                    fileName = "Marking_Scheme_Template.csv";
                } else if (btn.id === 'downloadResponseTemplateBtn') {
                    templateData = formatSelector.value === 'neet_other' ? "FRMID,Q1,Q2,Q3\n12345678,A,B,C" : "FRMID,F001,F002,F003\n12345678,A,B,C";
                    fileName = "Student_Response_Template.csv";
                } else if (btn.id.includes('downloadDetailsTemplateBtn')) {
                    templateData = "FRMID,Student Name,Batch\n12345678,Amit Kumar,Target Batch";
                    fileName = "Student_Details_Template.csv";
                }
                
                const blob = new Blob([templateData], { type: 'text/csv;charset=utf-8;' });
                const link = document.createElement("a");
                link.href = URL.createObjectURL(blob);
                link.download = fileName;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
            });
        });

        // --- NEW Statistics Functions ---
        function calculateOverallStats(scores) {
            const totalStudents = scores.length;
            if (totalStudents === 0) {
                overallStats = { totalStudents: 0, average: 0, highestScore: 0, lowestScore: 0, aboveAverage: 0, belowAverage: 0 };
                return;
            }
            const sum = scores.reduce((acc, score) => acc + score, 0);
            const average = sum / totalStudents;
            const highestScore = Math.max(...scores);
            const lowestScore = Math.min(...scores);
            const aboveAverage = scores.filter(score => score >= average).length;
            const belowAverage = scores.filter(score => score < average).length;

            overallStats = { totalStudents, average, highestScore, lowestScore, aboveAverage, belowAverage };
        }
        function renderStats() {
            const container = document.getElementById('summaryStatsContainer');
            if (!container) return;
            container.innerHTML = `
                <div class="stats-container">
                    <div class="stat-box"><div class="value">${overallStats.totalStudents}</div><div class="label">Total Students</div></div>
                    <div class="stat-box"><div class="value high">${formatNumberToTwoDecimals(overallStats.highestScore)}</div><div class="label">Highest Score</div></div>
                    <div class="stat-box"><div class="value">${formatNumberToTwoDecimals(overallStats.average)}</div><div class="label">Average Score</div></div>
                    <div class="stat-box"><div class="value low">${formatNumberToTwoDecimals(overallStats.lowestScore)}</div><div class="label">Lowest Score</div></div>
                    <div class="stat-box"><div class="value">${overallStats.aboveAverage}</div><div class="label">Students Above Avg.</div></div>
                    <div class="stat-box"><div class="value">${overallStats.belowAverage}</div><div class="label">Students Below Avg.</div></div>
                </div>
            `;
        }
        
        function addStatisticsToPdf(doc) {
            const testName = testNameInput.value.trim();
            const testDate = testDateInput.value ? formatDateToDdMmmYyyy(testDateInput.value) : '';
            
            const pageWidth = doc.internal.pageSize.getWidth();
            const margin = 10;
            
            doc.setFontSize(16);
            doc.setFont("helvetica", "bold");
            doc.text("Test Results", pageWidth / 2, margin + 8, { align: 'center' });
            
            doc.setFontSize(12);
            doc.setFont("helvetica", "normal");
            doc.text(`${testName} | ${testDate}`, pageWidth / 2, margin + 16, { align: 'center' });

            // Reset font for the table
            doc.setFontSize(9);
        }


        /** New Data Merger Logic **/
        const mergerApp = {
            file1Input: document.getElementById('file1-merger'),
            file2Input: document.getElementById('file2-merger'),
            file1Name: document.getElementById('file1Name-merger'),
            file2Name: document.getElementById('file2Name-merger'),
            mergeBtn: document.getElementById('mergeBtn'),
            errorMessage: document.getElementById('mergerErrorMessage'),
            resultsSection: document.getElementById('mergerResultsSection'),
            tableContainer: document.getElementById('mergerTableContainer'),
            downloadExcelBtn: document.getElementById('mergerDownloadExcelBtn'),
            downloadPdfBtn: document.getElementById('mergerDownloadPdfBtn'),
            testNameInput1: document.getElementById('testNameInput1'),
            testDateInput1: document.getElementById('testDateInput1'),
            clearObjSubjMergerBtn: document.getElementById('clearObjSubjMergerBtn'),


            file3Input: document.getElementById('file3-merger'),
            file4Input: document.getElementById('file4-merger'),
            file3Name: document.getElementById('file3Name-merger'),
            file4Name: document.getElementById('file4Name-merger'),
            mergeObjObjBtn: document.getElementById('mergeObjObjBtn'),
            errorMessageObjObj: document.getElementById('mergerObjObjErrorMessage'),
            resultsObjObjSection: document.getElementById('mergerObjObjResultsSection'),
            tableObjObjContainer: document.getElementById('mergerObjObjTableContainer'),
            downloadObjObjExcelBtn: document.getElementById('mergerObjObjDownloadExcelBtn'),
            downloadObjObjPdfBtn: document.getElementById('mergerObjObjDownloadPdfBtn'),
            testNameInput2: document.getElementById('testNameInput2'),
            testDateInput2: document.getElementById('testDateInput2'),
            clearObjObjMergerBtn: document.getElementById('clearObjObjMergerBtn'),

            file1Data: null,
            file2Data: null,
            file3Data: null,
            file4Data: null,
            processedData: [],
            excelHeaders: [],
            mergerTestInfo: { fullTitle: '', date: '' },
            totalMaxMarks: 0,
            totalMarksHeader: '',
            
            init: function() {
                const self = this;
                // Event listeners for Objective + Subjective Merger
                this.file1Input.addEventListener('change', (e) => this.handleFileSelect(e, 1));
                this.file2Input.addEventListener('change', (e) => this.handleFileSelect(e, 2));
                this.mergeBtn.addEventListener('click', () => this.processAndMerge(1));
                this.downloadExcelBtn.addEventListener('click', () => this.downloadExcel(1));
                this.downloadPdfBtn.addEventListener('click', () => this.downloadPDF(1));
                this.clearObjSubjMergerBtn.addEventListener('click', () => clearMergerFields(1));
                
                // Event listeners for Objective + Objective Merger
                this.file3Input.addEventListener('change', (e) => this.handleFileSelect(e, 3));
                this.file4Input.addEventListener('change', (e) => this.handleFileSelect(e, 4));
                this.mergeObjObjBtn.addEventListener('click', () => this.processAndMerge(2));
                this.downloadObjObjExcelBtn.addEventListener('click', () => this.downloadExcel(2));
                this.downloadObjObjPdfBtn.addEventListener('click', () => this.downloadPDF(2));
                this.clearObjObjMergerBtn.addEventListener('click', () => clearMergerFields(2));

                document.getElementById('objSubjMergerTabBtn').addEventListener('click', (e) => this.changeTab(e, 'objSubjMerger'));
                document.getElementById('objObjMergerTabBtn').addEventListener('click', (e) => this.changeTab(e, 'objObjMerger'));

                // Set initial state
                const initialTab = document.getElementById('objSubjMergerTabBtn');
                if (initialTab) {
                    this.changeTab({ currentTarget: initialTab }, 'objSubjMerger');
                }

                // Event listeners for enabling buttons
                [this.file1Input, this.file2Input].forEach(input => input.addEventListener('change', () => this.checkMergeButtonState(1)));
                [this.file3Input, this.file4Input].forEach(input => input.addEventListener('change', () => this.checkMergeButtonState(2)));
            },
            
            changeTab: function(event, tabId) {
                document.querySelectorAll('.merger-tab-content').forEach(tab => tab.style.display = 'none');
                document.querySelectorAll('.merger-tab-nav .tab-btn').forEach(btn => btn.classList.remove('active'));
                document.getElementById(tabId).style.display = 'block';
                event.currentTarget.classList.add('active');
            },
            
            parseExcelFile: function(file, callback) {
                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        const data = new Uint8Array(e.target.result);
                        const workbook = XLSX.read(data, { type: 'array' });
                        const firstSheetName = workbook.SheetNames[0];
                        const worksheet = workbook.Sheets[firstSheetName];
                        const allRows = XLSX.utils.sheet_to_json(worksheet, { header: 1 });
                        
                        let headerRowIndex = -1;
                        for (let i = 0; i < allRows.length; i++) {
                             if (Array.isArray(allRows[i]) && allRows[i].some(h => String(h).trim().toLowerCase() === 'fno.')) {
                                 headerRowIndex = i;
                                 break;
                             }
                        }
                        
                        if (headerRowIndex === -1) {
                            callback({ error: 'Fno. header not found' });
                            return;
                        }
                        
                        const jsonData = XLSX.utils.sheet_to_json(worksheet, { range: headerRowIndex });
                        const headerRow = allRows[headerRowIndex] || [];
                        const a1Value = (allRows.length > 0 && allRows[0].length > 0) ? allRows[0][0] : "Unnamed Test";

                        if (jsonData.length === 0 || headerRow.length === 0) {
                            callback({ error: 'File is empty or could not find header' });
                            return;
                        }

                        callback({ data: jsonData, headers: headerRow, a1Value: a1Value });
                    } catch (err) {
                        callback({ error: `Error parsing file: ${err.message}` });
                    }
                };
                reader.onerror = (err) => callback({ error: `Error reading file: ${err.message}` });
                reader.readAsArrayBuffer(file);
            },

            handleFileSelect: function(event, fileNum) {
                const file = event.target.files[0];
                const fileNameDisplay = document.getElementById(`file${fileNum}Name-merger`);
                if (!file) {
                    fileNameDisplay.textContent = 'No file chosen';
                    this[`file${fileNum}Data`] = null;
                    this.checkMergeButtonState(fileNum);
                    return;
                }
                
                this.parseExcelFile(file, (result) => {
                    if (result.error) {
                        document.getElementById(`merger${fileNum > 2 ? 'ObjObj' : ''}ErrorMessage`).textContent = result.error;
                        document.getElementById(`merger${fileNum > 2 ? 'ObjObj' : ''}ErrorMessage`).style.display = 'block';
                        this[`file${fileNum}Data`] = null;
                    } else {
                        fileNameDisplay.textContent = `Chosen: ${file.name}`;
                        this[`file${fileNum}Data`] = result;
                        document.getElementById(`merger${fileNum > 2 ? 'ObjObj' : ''}ErrorMessage`).textContent = '';
                        document.getElementById(`merger${fileNum > 2 ? 'ObjObj' : ''}ErrorMessage`).style.display = 'none';
                    }
                    this.checkMergeButtonState(fileNum);
                });
            },

            checkMergeButtonState: function(fileNum) {
                if (fileNum <= 2) {
                    this.mergeBtn.disabled = !(this.file1Data && !this.file1Data.error && this.file2Data && !this.file2Data.error);
                } else {
                    this.mergeObjObjBtn.disabled = !(this.file3Data && !this.file3Data.error && this.file4Data && !this.file4Data.error);
                }
            },
            
            processAndMerge: function(tabNum) {
                let file1Data, file2Data, testNameInput, testDateInput;
                if (tabNum === 1) {
                    file1Data = this.file1Data; file2Data = this.file2Data;
                    testNameInput = this.testNameInput1; testDateInput = this.testDateInput1;
                } else {
                    file1Data = this.file3Data; file2Data = this.file4Data;
                    testNameInput = this.testNameInput2; testDateInput = this.testDateInput2;
                }

                const file1Subjects = this.extractSubjects(file1Data.headers);
                const file2Subjects = this.extractSubjects(file2Data.headers);
                const commonSubjects = new Set(Object.keys(file1Subjects).filter(name => Object.keys(file2Subjects).includes(name)));

                this.mergerTestInfo.fullTitle = testNameInput.value ? `Test Result: ${testNameInput.value}` : `Merged Test Results`;
                this.mergerTestInfo.date = testDateInput.value ? formatDateToDdMmmYyyy(testDateInput.value) : '';

                const file1MaxMarks = Object.values(file1Subjects).reduce((sum, s) => sum + s.maxMarks, 0);
                const file2MaxMarks = Object.values(file2Subjects).reduce((sum, s) => sum + s.maxMarks, 0);
                this.totalMaxMarks = file1MaxMarks + file2MaxMarks;
                this.totalMarksHeader = `Total Marks (${this.totalMaxMarks})`;

                const file1Map = new Map(file1Data.data.map(row => [String(row['Fno.'] || '').trim(), row]));
                const file2Map = new Map(file2Data.data.map(row => [String(row['Fno.'] || '').trim(), row]));
                const allFormNos = new Set([...file1Map.keys(), ...file2Map.keys()]);
                
                let tempData = [];
                allFormNos.forEach(formNo => {
                    if (!formNo) return;
                    const row1 = file1Map.get(formNo);
                    const row2 = file2Map.get(formNo);
                    const student = { 'Fno.': formNo };

                    student['Student Name'] = (row1 && row1['Student Name']) || (row2 && row2['Student Name']) || '';
                    student['Batch'] = (row1 && row1['Batch']) || (row2 && row2['Batch']) || '';

                    let combinedTotalScore = 0;

                    Object.keys(file1Subjects).forEach(subjKey => {
                        const score = (row1 && parseFloat(row1[file1Subjects[subjKey].originalHeader])) || 0;
                        const prefix = (tabNum === 1) ? 'OBJ' : 'P1';
                        student[`${prefix}-${subjKey} (${file1Subjects[subjKey].maxMarks})`] = score;
                    });
                    
                    Object.keys(file2Subjects).forEach(subjKey => {
                        const score = (row2 && parseFloat(row2[file2Subjects[subjKey].originalHeader])) || 0;
                        const prefix = (tabNum === 1) ? 'SUBJ' : 'P2';
                        student[`${prefix}-${subjKey} (${file2Subjects[subjKey].maxMarks})`] = score;
                    });

                    Object.keys({...file1Subjects, ...file2Subjects}).forEach(subjKey => {
                        const max1 = file1Subjects[subjKey] ? file1Subjects[subjKey].maxMarks : 0;
                        const max2 = file2Subjects[subjKey] ? file2Subjects[subjKey].maxMarks : 0;
                        const score1 = student[`${tabNum === 1 ? 'OBJ' : 'P1'}-${subjKey} (${max1})`] || 0;
                        const score2 = student[`${tabNum === 1 ? 'SUBJ' : 'P2'}-${subjKey} (${max2})`] || 0;
                        const totalSubjScore = score1 + score2;
                        
                        if (commonSubjects.has(subjKey)) {
                            student[`MERGED-${subjKey} (${max1 + max2})`] = totalSubjScore;
                        }
                        combinedTotalScore += totalSubjScore;
                    });
                    
                    student[this.totalMarksHeader] = combinedTotalScore;
                    student['%age'] = (this.totalMaxMarks > 0 ? (combinedTotalScore / this.totalMaxMarks) * 100 : 0).toFixed(2);
                    tempData.push(student);
                });

                const overallRanker = this.rankSorter(this.totalMarksHeader, []);
                tempData.sort(overallRanker);

                const totalStudents = tempData.length;
                tempData.forEach((student, index, array) => {
                    student['Sno.'] = index + 1;
                    const rank = (index > 0 && overallRanker(student, array[index - 1]) === 0) ? array[index - 1]['Rank'] : index + 1;
                    student['Rank'] = rank;
                    student['Percentile'] = (totalStudents > 0 ? (((totalStudents - rank) / (totalStudents - 1)) * 100) : 0).toFixed(2);
                });

                this.processedData = tempData;
                this.displayTable(tabNum);
            },

            extractSubjects: function(headers) {
                const subjects = {};
                if (!Array.isArray(headers)) return subjects;
                const subjectRegex = /(.+?)\s*\((\d+(?:\.\d+)?)\)/;
                headers.forEach(h => {
                    if (typeof h === 'string') {
                        const match = h.match(subjectRegex);
                        if (match && !/total|sno|fno|name|batch|%age|rank|percentile/i.test(h)) {
                            subjects[match[1].trim().toUpperCase()] = { originalHeader: h, maxMarks: parseFloat(match[2]) };
                        }
                    }
                });
                return subjects;
            },

            rankSorter: function(totalKey, tieBreakerKeys) {
                return (a, b) => {
                    if ((a[totalKey] || 0) !== (b[totalKey] || 0)) return (b[totalKey] || 0) - (a[totalKey] || 0);
                    for (const key of tieBreakerKeys) {
                        if ((a[key] || 0) !== (b[key] || 0)) return (b[key] || 0) - (a[key] || 0);
                    }
                    return 0;
                };
            },

            displayTable: function(tabNum) {
                if (this.processedData.length === 0) return;

                let tableContainer, downloadBtn, downloadPdfBtn, resultsSection, paginationId;
                if (tabNum === 1) {
                    tableContainer = this.tableContainer; downloadBtn = this.downloadExcelBtn;
                    downloadPdfBtn = this.downloadPdfBtn; resultsSection = this.resultsSection;
                    paginationId = 'mergerPagination1';
                } else {
                    tableContainer = this.tableObjObjContainer; downloadBtn = this.downloadObjObjExcelBtn;
                    downloadPdfBtn = this.downloadObjObjPdfBtn; resultsSection = this.resultsObjObjSection;
                    paginationId = 'mergerPagination2';
                }

                resultsSection.style.display = 'block';

                const firstStudent = this.processedData[0];
                const file1SubjectHeaders = Object.keys(firstStudent).filter(key => key.startsWith('OBJ-') || key.startsWith('P1-')).sort();
                const file2SubjectHeaders = Object.keys(firstStudent).filter(key => key.startsWith('SUBJ-') || key.startsWith('P2-')).sort();
                const mergedSubjectHeaders = Object.keys(firstStudent).filter(key => key.startsWith('MERGED-')).sort();
                const finalHeaders = [this.totalMarksHeader, '%age', 'Percentile', 'Rank'];
                
                this.excelHeaders = ['Sno.', 'Fno.', 'Student Name', 'Batch', ...file1SubjectHeaders, ...file2SubjectHeaders, ...mergedSubjectHeaders, ...finalHeaders];
                
                renderTableWithPagination(tableContainer.id, paginationId, this.processedData, 10, (row) => {
                    let rowHtml = `<td class="sticky-col">${row['Sno.']}</td>`;
                    this.excelHeaders.slice(1).forEach(key => {
                        const value = row[key] !== undefined ? row[key] : '';
                        rowHtml += `<td>${value}</td>`;
                    });
                    return rowHtml;
                }, () => this.excelHeaders);


                downloadBtn.disabled = false;
                downloadPdfBtn.disabled = false;
            },
            
            _getFileName: function() {
                const today = new Date();
                const dateStr = `${String(today.getDate()).padStart(2, '0')}-${String(today.getMonth() + 1).padStart(2, '0')}-${today.getFullYear()}`;
                const batchName = this.processedData.length > 0 ? (this.processedData[0].Batch || 'Report').replace(/\s+/g, '_') : 'Report';
                return `Merged_${dateStr}_${batchName}`;
            },

            downloadExcel: function(tabNum) {
                if (this.processedData.length === 0) return;
                
                const fileName = this._getFileName() + '.xlsx';
                const title = this.mergerTestInfo.fullTitle;
                const subtitle = this.mergerTestInfo.date ? `Test Date: ${this.mergerTestInfo.date}` : '';
                
                const firstStudent = this.processedData[0] || {};
                const file1Headers = this.excelHeaders.filter(h => h.startsWith('OBJ-') || h.startsWith('P1-'));
                const file2Headers = this.excelHeaders.filter(h => h.startsWith('SUBJ-') || h.startsWith('P2-'));
                const mergedHeaders = this.excelHeaders.filter(h => h.startsWith('MERGED-'));

                const groupHeaders = [
                    { name: "Student Info", span: 4 },
                    { name: tabNum === 1 ? 'Objective Score' : 'Paper 1 Score', span: file1Headers.length },
                    { name: tabNum === 1 ? 'Subjective Score' : 'Paper 2 Score', span: file2Headers.length },
                    { name: 'Merged Marks', span: mergedHeaders.length },
                    { name: 'Overall Score & Rank', span: 4 }
                ].filter(g => g.span > 0);

                const dataRows = this.processedData.map(row => {
                    return this.excelHeaders.map(header => (row[header] !== undefined ? row[header] : ''));
                });

                exportStyledExcel(fileName, 'Merged Results', title, subtitle, this.excelHeaders, dataRows, groupHeaders);
            },

            downloadPDF: function(tabNum) {
                if (this.processedData.length === 0) return;
                
                const { jsPDF } = window.jspdf;
                const doc = new jsPDF({ orientation: 'landscape', unit: 'pt', format: 'a4' });

                doc.setFontSize(12);
                doc.setFont('helvetica', 'bold');
                doc.text(this.mergerTestInfo.fullTitle, doc.internal.pageSize.getWidth() / 2, 30, { align: 'center' });
                
                doc.setFontSize(10);
                doc.setFont('helvetica', 'normal');
                if (this.mergerTestInfo.date) {
                    doc.text(`Test Date: ${this.mergerTestInfo.date}`, doc.internal.pageSize.getWidth() / 2, 45, { align: 'center' });
                }

                const startY = this.mergerTestInfo.date || this.mergerTestInfo.fullTitle ? 60 : 45;

                const firstStudent = this.processedData[0];
                const file1SubjectHeaders = Object.keys(firstStudent).filter(key => key.startsWith('P1-') || key.startsWith('OBJ-'));
                const file2SubjectHeaders = Object.keys(firstStudent).filter(key => key.startsWith('P2-') || key.startsWith('SUBJ-'));
                const mergedSubjectHeaders = Object.keys(firstStudent).filter(key => key.startsWith('MERGED-'));
                
                const allHeaderGroups = [
                    { content: 'Student Info', colSpan: 4, styles: { halign: 'center' } },
                    { content: tabNum === 1 ? 'Objective Score' : 'Paper 1 Score', colSpan: file1SubjectHeaders.length, styles: { halign: 'center' } },
                    { content: tabNum === 1 ? 'Subjective Score' : 'Paper 2 Score', colSpan: file2SubjectHeaders.length, styles: { halign: 'center' } },
                    { content: 'Merged Marks', colSpan: mergedSubjectHeaders.length, styles: { halign: 'center' } },
                    { content: 'Overall Score & Rank', colSpan: 4, styles: { halign: 'center' } }
                ];
                
                const finalHeaderGroups = allHeaderGroups.filter(group => group.colSpan > 0);
                
                let head = [
                    finalHeaderGroups,
                    [] 
                ];
                
                const subHeaders = ['Sno.', 'Fno.', 'Student Name', 'Batch', 
                                    ...file1SubjectHeaders, ...file2SubjectHeaders, ...mergedSubjectHeaders, 
                                    this.totalMarksHeader, '%age', 'Percentile', 'Rank'];
                                    
                head[1] = subHeaders.map(h => {
                    let header = h;

                    if (header === this.totalMarksHeader) {
                        return `Total Marks\n(${this.totalMaxMarks})`;
                    }

                    if (tabNum === 1) header = header.replace(/OBJ-|SUBJ-|MERGED-/g, '');
                    else if (tabNum === 2) header = header.replace(/P1-|P2-|MERGED-/g, '');
                    const match = header.match(/(.+?)\s*\((\d+(?:\.\d+)?)\)/);
                    return match ? `${match[1]}\n(${match[2]})` : header;
                });
                
                const body = this.processedData.map(row => subHeaders.map(key => row[key] !== undefined ? row[key] : ''));

                doc.autoTable({
                    head: head,
                    body: body,
                    startY: startY,
                    theme: 'grid',
                    rowPageBreak: 'avoid',
                    styles: { fontSize: 6.5, cellPadding: 2, halign: 'center', valign: 'middle', textColor: 0 },
                    headStyles: { fillColor: [220, 220, 220], textColor: 0, fontStyle: 'bold', halign: 'center', lineWidth: 0.5 },
                    columnStyles: { 2: { halign: 'left', fontStyle: 'bold', cellWidth: 75 }, },
                    didDrawPage: function (data) {
                        const today = new Date();
                        const printDate = `Print Date: ${today.toLocaleDateString()} ${today.toLocaleTimeString()}`;
                        doc.setFontSize(8);
                        doc.text(printDate, data.settings.margin.left, doc.internal.pageSize.height - 10);
                    }
                });

                const fileName = this._getFileName() + '.pdf';
                doc.save(fileName);
            }
        };
        mergerApp.init();

        updateUIForExamType('objective');
        
        document.querySelectorAll('.results-tab-btn').forEach(btn => {
            btn.addEventListener('click', (e) => {
                document.querySelectorAll('.results-tab-btn').forEach(b => b.classList.remove('active'));
                e.target.classList.add('active');
                
                document.querySelectorAll('.results-tab-content').forEach(content => content.classList.remove('active'));
                document.getElementById(e.target.dataset.tab).classList.add('active');
            });
        });
         document.querySelectorAll('input[type="date"]').forEach(input => {
            input.addEventListener('change', (e) => {
                if (e.target.value) {
                    e.target.classList.add('has-value');
                } else {
                    e.target.classList.remove('has-value');
                }
            });
             if (input.value) {
                 input.classList.add('has-value');
             }
        });
    });
</script>

</body>
</html>


